<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="2020-3年面试总结, 远行客">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>2020-3年面试总结 | 远行客</title>
    <link rel="icon" type="image/png" href="/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<link rel="alternate" href="/atom.xml" title="远行客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

    <!-- <script src="/js/snow.js"></script> -->

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
    </script>
        
     
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">远行客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">远行客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://blog-1257031229.cos.ap-shanghai.myqcloud.com/matery/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">2020-3年面试总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/面试/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/面试/" class="post-category">
                                面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-01
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-05-17
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    26 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <a id="more"></a> 
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/rabbitmq/rabbit%E6%9E%B6%E6%9E%84%E5%9B%BE1.jpg" alt=""></p>
<p><img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/rabbitmq/rabbit%E6%9E%B6%E6%9E%84%E5%9B%BE2.jpg" alt=""></p>
<ul>
<li><p><strong>Message</strong>:：消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系 </p>
<p>列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优 </p>
<p>先权）、delivery-mode（指出该消息可能需要持久性存储）等。 </p>
</li>
<li><p><strong>Publisher</strong>：消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
</li>
<li><p><strong>Exchange</strong>：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
</li>
<li><p><strong>Binding</strong>：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连 </p>
<p>接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>
</li>
<li><p><strong>Queue</strong>：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息 </p>
<p>  可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
</li>
<li><p><strong>Connection</strong>：网络连接，比如一个 TCP 连接。</p>
</li>
<li><p><strong>Channel</strong>：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内地虚 </p>
<p>  拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这 </p>
<p>  些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所 </p>
<p>  以引入了信道的概念，以复用一条 TCP 连接。 </p>
</li>
<li><p><strong>Consumer</strong>：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p>
</li>
<li><p><strong>Virtual Host</strong>：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密 </p>
<p>  环境的独立服务器域</p>
</li>
<li><p><strong>Broker</strong>：表示消息队列服务器实体。</p>
</li>
</ul>
<p><img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/rabbitmq/rabbit%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<p>rabbitmq的进程模型是事件驱动模型（或者说反应堆模型），这是一种高性能的非阻塞io线程模型。</p>
<ul>
<li><strong>tcp_acceptor</strong>：接收客户端连接，创建rabbit_reader、rabbit_writer、rabbit_channel进程。 </li>
<li><strong>rabbit_reader</strong>：接收客户端连接，解析AMQP帧；</li>
<li><strong>rabbit_writer</strong>：向客户端返回数据； </li>
<li><strong>rabbit_channel</strong>：解析AMQP方法，对消息进行路由，然后发给相应队列进程。 </li>
<li><strong>rabbit_amqqueue_process</strong>：是队列进程，在RabbitMQ启动（恢复durable类型队列）或创建队列时创建。 </li>
<li>r<strong>abbit_msg_store</strong>：负责消息持久化的进程。</li>
</ul>
<p>在整个系统中，存在一个tcp_accepter进程，一个rabbit_msg_store进程，有多少个队列就有多少个rabbit_amqqueue_process进程，每个客户端连接对应一个rabbit_reader和rabbit_writer进程。</p>
<h3 id="RabbitMQ-如何保证消息的顺序性？"><a href="#RabbitMQ-如何保证消息的顺序性？" class="headerlink" title="RabbitMQ 如何保证消息的顺序性？"></a>RabbitMQ 如何保证消息的顺序性？</h3><p>拆分为多个queue，每个queue由一个consumer消费；<br>或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理</p>
<h3 id="如何确保消息正确地发送至-RabbitMQ"><a href="#如何确保消息正确地发送至-RabbitMQ" class="headerlink" title="如何确保消息正确地发送至 RabbitMQ"></a>如何确保消息正确地发送至 RabbitMQ</h3><p>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。<br>一旦消息被投递到目的队列后，信道会发送一个确认（ack）给生产者（包含消息唯一 ID）。<br>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。<br>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。<br>当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<h3 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h3><p>消息持久化，当然前提是队列必须持久化<br>RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit 会在消息提交到日志文件后才发送响应。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前 RabbitMQ 重启，那么 Rabbit 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。</p>
<h3 id="如何确保消息接收方消费了消息"><a href="#如何确保消息接收方消费了消息" class="headerlink" title="如何确保消息接收方消费了消息"></a>如何确保消息接收方消费了消息</h3><p>这部分要处理的场景是： 当消费者接收到消息后，还没处理完业务逻辑，消费者挂掉了，此时消息等同于丢失了。</p>
<p>为了确保消息被消费者成功消费，RabbitMQ提供了消息确认机制，主要通过显示Ack模式来实现。</p>
<p>默认情况下，RabbitMQ会自动把发送出去的消息置为确认，然后从内存(或磁盘)删除，但是我们在使用时可以手动设置autoAck为False的</p>
<p>需要注意的时，如果设置autoAck为false，也就意味者每条消息需要我们自己发送ack确认，RabbitMQ才能正确标识消息的状态。</p>
<h3 id="如何避免消息重复投递或重复消费"><a href="#如何避免消息重复投递或重复消费" class="headerlink" title="如何避免消息重复投递或重复消费"></a>如何避免消息重复投递或重复消费</h3><p>在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；<br>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一条消息被重复消费。</p>
<h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><h3 id="RabbitMQ-镜像集群模式"><a href="#RabbitMQ-镜像集群模式" class="headerlink" title="RabbitMQ 镜像集群模式"></a>RabbitMQ 镜像集群模式</h3><p>你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。<br>好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p><img src="https://upload-images.jianshu.io/upload_images/11224747-5139249680a222cf.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt=""></p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><a href="https://segmentfault.com/a/1190000016721700" target="_blank" rel="noopener">布隆过滤器</a></p>
<h3 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h3><p><a href="https://www.cnblogs.com/52fhy/p/9786720.html" target="_blank" rel="noopener">Reids 使用Lua脚本</a></p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p><a href="https://blog.csdn.net/lxl_jiayou/article/details/105349278" target="_blank" rel="noopener">redis rehash</a></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<ul>
<li>在批量往<strong>Redis</strong>存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p>
<ul>
<li>最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>另外也有一个更为<strong>简单粗暴的方法</strong>，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>这个跟<strong>缓存雪崩</strong>有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是<strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞</p>
<ul>
<li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li>
<li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li>
</ul>
<h3 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h3><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p>如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。</p>
<p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CACHE_SIZE<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 传递进来最多能缓存多少数据
     *
     * @param cacheSize 缓存大小
     */</span>
    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>cacheSize <span class="token operator">/</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CACHE_SIZE <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> CACHE_SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<h3 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h3><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h3 id="分布式锁注意事项"><a href="#分布式锁注意事项" class="headerlink" title="分布式锁注意事项"></a>分布式锁注意事项</h3><ol>
<li>设置的key必须要有过期时间，防止崩溃时锁无法释放</li>
<li>value使用唯一id标志每个客户端，保证只有锁的持有者才可以释放锁</li>
</ol>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="Mysql逻辑架构图"><a href="#Mysql逻辑架构图" class="headerlink" title="Mysql逻辑架构图"></a>Mysql逻辑架构图</h3><p><img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/mysql/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><ul>
<li>原子性：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。 </li>
<li>一致性：当事务完成时，数据必须处于一致状态。</li>
<li>隔离性：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。 </li>
<li>永久性：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</li>
</ul>
<h3 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h3><ul>
<li><strong>脏读</strong> ：<em>指一个事务处理过程中读取了另一个事务未提交的数据</em>。比如，事务A读取了事务B中尚未提交的数据。如果事务B回滚，则A读取使用了错误的数据。</li>
<li><strong>不可重复读</strong>：<em>对于数据库中的某个数据，一个事务范围内多次查询返回了不同的值</em>，这是由于在查询间隔，被另一个事务<strong>修改</strong>并提交了。例如，事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务，当事务T1再次读取该数据就得到了不同的结果，即发生了不可重复读。</li>
<li><strong>幻读</strong>：<em>指在一个事务读的过程中，另外一个事务可能<strong>插入（删除）</strong>了数据记录，影响了该事务读的结果</em>。例如，事务 T1 对一个表中所有的行的某个数据项执行了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。这时，操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li>
</ul>
<h3 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a>数据库事务隔离级别</h3><ul>
<li><strong>Serializable（串行化）:</strong> 最高级别，可避免脏读、不可重复读、幻读</li>
<li><strong>Repeatable read（可重复读）:</strong> 可避免脏读、不可重复读的发生（mysql默认）</li>
<li><strong>Read committed（读已提交）:</strong> 可避免脏读的发生（Oracle默认）</li>
<li><strong>Read uncommitted（读未提交）:</strong> 最低级别，任何情况都无法避免</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">MVCC理解</a></p>
<p><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">MVCC实现</a></p>
<h3 id="redo-log-重做日志-，undo-log-回滚日志-，-bin-log-二进制日志"><a href="#redo-log-重做日志-，undo-log-回滚日志-，-bin-log-二进制日志" class="headerlink" title="redo log(重做日志)，undo  log(回滚日志)， bin log(二进制日志)"></a>redo log(重做日志)，undo  log(回滚日志)， bin log(二进制日志)</h3><p><a href="https://www.cnblogs.com/wy123/p/8365234.html" target="_blank" rel="noopener">三种日志</a></p>
<h3 id="InnoDB锁的特性"><a href="#InnoDB锁的特性" class="headerlink" title="InnoDB锁的特性"></a>InnoDB锁的特性</h3><ul>
<li>在不通过索引条件查询的时候，InnoDB使用的是表锁</li>
<li>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁,所以虽然是访问不同行的记录,但是如果是使用相同的索引键,是会出现锁冲突的。</li>
<li>当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。</li>
<li>即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的,如果 MySQL 认为全表扫效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。</li>
</ul>
<h3 id="InnoDB的锁分类"><a href="#InnoDB的锁分类" class="headerlink" title="InnoDB的锁分类"></a>InnoDB的锁分类</h3><ul>
<li>Record Lock：行锁：单个行记录上的行锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身</li>
<li><p>Next-Key Lock：Gap+Record Lock，锁定一个范围，并且锁定记录本身</p>
<p>Read committed（读已提交）仅有Record Lock</p>
</li>
</ul>
<p>Repeatable read（可重复读）有Record Lock和Next-Key Lock</p>
<h3 id="update语句执行过程"><a href="#update语句执行过程" class="headerlink" title="update语句执行过程"></a>update语句执行过程</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> T <span class="token keyword">set</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">c</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<h3 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h3><ul>
<li>避免全表扫描</li>
<li>避免索引失效</li>
<li>避免排序，不能避免，尽量选择索引排序</li>
<li>避免查询不必要的字段</li>
<li>避免临时表的创建，删除</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul>
<li>使用like时通配符在前</li>
<li>在查询条件中使用OR</li>
<li>对索引列进行函数运算</li>
<li>MYSQL使用不等于（&lt;,&gt;,!=）的时候无法使用索引，会导致索引失效</li>
<li>当使用or关键字进行查询时候，只有当or两边的查询条件都是索引列时候，才使用索引</li>
<li>尽可能的使用 varchar/nvarchar 代替 char/nchar （节省字段存储空间）</li>
<li>联合索引ABC问题： Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是index (a,b,c)，可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c或c进行查找 。</li>
<li>优化嵌套查询 ：某些子查询可以通过join来代替。理由：join不需要在内存中创建一个临时表来存储数据。</li>
<li>使用not exist代替not in：如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引</li>
</ul>
<h3 id="in-和-exist-区别选择"><a href="#in-和-exist-区别选择" class="headerlink" title="in 和 exist 区别选择"></a>in 和 exist 区别选择</h3><p>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。</p>
<p>因此，in用到的是外表的索引， exists用到的是内表的索引。</p>
<pre><code> 如果查询的两个表大小相当，那么用in和exists差别不大，

 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in
</code></pre><h3 id="回表-、覆盖索引、聚簇、非聚簇索引"><a href="#回表-、覆盖索引、聚簇、非聚簇索引" class="headerlink" title="回表 、覆盖索引、聚簇、非聚簇索引"></a>回表 、覆盖索引、聚簇、非聚簇索引</h3><ul>
<li>回表：需要先定位主键值，再定位行记录的查询  叫回表</li>
<li>覆盖索引：一个索引包含所有要查询的字段的值叫覆盖索引</li>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，也叫辅助索引，二级索引</li>
</ul>
<h3 id="SQL执行计划"><a href="#SQL执行计划" class="headerlink" title="SQL执行计划"></a>SQL执行计划</h3><pre class=" language-shell"><code class="language-shell">mysql> EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
</code></pre>
<ul>
<li>id:  在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</li>
<li>select_type:    SELECT关键字对应的那个查询的类型</li>
<li>table    表名</li>
<li>partitions:    匹配的分区信息</li>
<li>type:    针对单表的访问方法</li>
<li>possible_keys:    可能用到的索引</li>
<li>key:    实际上使用的索引</li>
<li>key_len:    实际使用到的索引长度</li>
<li>ref:    当使用索引列等值查询时，与索引列进行等值匹配的对象信息</li>
<li>rows:    预估的需要读取的记录条数</li>
<li>filtered:    某个表经过搜索条件过滤后剩余记录条数的百分比</li>
<li>Extra:    一些额外的信息</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="IOC-AOP原理"><a href="#IOC-AOP原理" class="headerlink" title="IOC AOP原理"></a>IOC AOP原理</h3><ul>
<li>IOC : 工厂+反射</li>
<li>AOP: 动态代理+责任链拦截器   有接口-JDK动态代理   无接口-CGlib</li>
</ul>
<h3 id="ioc初始化过程"><a href="#ioc初始化过程" class="headerlink" title="ioc初始化过程"></a>ioc初始化过程</h3><p>加载配置文件—通过Resource定位BeanDefinition—-存入DefaultListableBeanFactory—通过loadBeanDefinitions()来完成BeanDefinition信息的载入—将抽象好的BeanDefinition注册到IoC容器中</p>
<h3 id="Spring-Bean-生命周期-实例化Bean过程"><a href="#Spring-Bean-生命周期-实例化Bean过程" class="headerlink" title="Spring Bean 生命周期(实例化Bean过程)"></a><strong>Spring Bean</strong> 生命周期(实例化Bean过程)</h3><p><img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/spring/springBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<ol>
<li>实例化对象；</li>
<li>填充属性值及引用；</li>
<li>调用 <code>BeanNameAware</code> 的 <code>setBeanName(String name)</code> 设置 bean 的 id；</li>
<li>调用 <code>BeanFactoryAware</code> 的 <code>setBeanFactory(BeanFactory beanFactory)</code> 设置 <code>BeanFactory</code> Bean工厂；</li>
<li>同上：<code>ApplicationContextAware`</code>setApplicationContext(ApplicationContext applicationContext)`；</li>
<li>如果实现 <code>BeanPostProcessor</code>，则 调用 postProcessBeforeInitialization() 初始化前的后置处理方法</li>
<li>如果实现了 <code>InitializingBean</code> 接口，则使用 <code>afterPropertiesSet()</code> 来初始化属性</li>
<li>如果实现 <code>BeanPostProcessor</code>，则 调用 postProcessAfterInitialization() 初始化后的后置处理方法</li>
<li>此时，bean 就可以使用了</li>
<li><code>DisposableBean</code>接口 <code>destroy()</code> 销毁bean。不过在Spring5.0开始</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="Mybatis-中-与-的区别"><a href="#Mybatis-中-与-的区别" class="headerlink" title="Mybatis 中 $  与 # 的区别"></a>Mybatis 中 $  与 # 的区别</h3><p>$相当于对数据加上双引号，$则是什么就显示什么</p>
<p>如：id = #{id}，如果传入的值是99,那么解析成sql时的值为 id =“99”</p>
<p>如：id = ${id}，如果传入的值是99,那么解析成sql时的值为d = 99</p>
<p>$方式一般用于传入数据库对象，例如传入表名</p>
<p> 活order b动态排序</p>
<h3 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h3><ul>
<li><p><strong>一级缓存</strong>：一级缓存是SQLSession级别的，SqlSession对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域（HashMap）是互相不影响的。Mybatis默认开启一级缓存，不需要进行任何配置。</p>
<p>当在同一个SqlSession中执行两次相同的sql语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存）中，第二次查询时会从缓存中获取数据，不再去底层进行数据库查询，如果SqlSession执行了DML操作（insert、update、delete），并执行commit（）操作，mybatis则会清空SqlSession中的一级缓存</p>
</li>
<li><strong>二级缓存</strong>：二级缓存是mapper级别的缓存。其作用域是mapper的同一个namespace，不同的SqlSession两次执行相同的namespace下的sql语句，且向sql中传递的参数也相同，即最终执行相同的sql语句，则第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次查询时会从缓存中获取数据，不再去底层数据库查询，从而提高查询效率。<br>Mybatis默认没有开启二级缓存，需要在setting全局参数中配置开启二级缓存。</li>
</ul>
<h3 id="Mybatis-Mapper-Dao接口工作原理"><a href="#Mybatis-Mapper-Dao接口工作原理" class="headerlink" title="Mybatis  Mapper/Dao接口工作原理"></a>Mybatis  Mapper/Dao接口工作原理</h3><p>Mapper接口全限定名对应映射文件中的namespace的值，Mapper接口的方法名对应映射文件中SQL的id值，接口方法内的参数对应应映射文件中SQL的paramType值，接口方法返回值对应映射文件中的SQL的resultMap/result。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><ol>
<li>用户向服务器发送请求，请求被SpringMVC的前端控制器DispatcherServlet拦截</li>
<li>DispatcherServlet对请求URL进行解析，调用HandlerMapping获得该Handler配置的所有相关对象，包括Handler对象以及Handler对象对应的拦截器，这些对象被封装到一个HandlerExecutionchain当中返回</li>
<li>DispatcherServlet根据获得的Handler（Controller），选择一个合适的HandlerAdapter。一个HandlerAdapter会被用于处理多种（一类）Handler，并调用Handler实际处理请求的方法。</li>
<li>在调用Handler实际处理请求的方法之前，HandlerAdapter首先会结合用户配置对请求消息进行转换（序列化），然后通过DataBinder将请求中的模型数据绑定到Handler对应的处理方法的参数中。</li>
<li>Handler调用业务逻辑组件完成对请求的处理后，向DispatcherServlet返回一个ModelAndView对象，ModelAndView对象中应该包含视图名或者视图和模型。</li>
<li>DispatcherServlet调用视图解析器ViewResolver结合Model来渲染视图</li>
<li>DispatcherServlet将视图渲染结果返回给客户端</li>
</ol>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>@SpringBootApplication----@EnableAutoConfiguration---@Import({AutoConfigurationImportSelector.class})</p>
<p>AutoConfigurationImportSelector类中的selectImports方法执行完毕后,Spring会把这个方法返回的类的全限定名数组里的所有的类都注入到IOC容器中</p>
<h2 id="多线程-并发与锁"><a href="#多线程-并发与锁" class="headerlink" title="多线程,并发与锁"></a>多线程,并发与锁</h2><h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><p><a href="https://blog.csdn.net/javazejian/article/details/72828483?locationNum=5&amp;fps=1" target="_blank" rel="noopener">synchronized原理</a></p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p>synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<h3 id="Lock-AQS原理"><a href="#Lock-AQS原理" class="headerlink" title="Lock/AQS原理"></a>Lock/AQS原理</h3><p><a href="https://segmentfault.com/a/1190000017372067#item-3-8" target="_blank" rel="noopener">AQS原理</a></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>​      Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。</p>
<p>​      你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。</p>
<p>​      CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p>
<h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p><strong>可见性</strong>：对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个本地内存中的变量同步到系统主内存中。对于其他线程，volatile变量在每次使用之前都从主内存刷新</p>
<p><strong>有序性</strong>：禁止指令重排序（编译器对操作volatile的变量不再进行优化）</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><strong>1.7</strong> : Segment + HashEntry ,Segment 继承ReentrantLock—–tryLock（）+自旋获取锁,超过指定次数就挂起，等待唤醒      HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值(读不加锁)。</li>
<li><strong>1.8 </strong>: Node + CAS + Synchronized+红黑树   Node中的 <code>val next</code> 都用了 volatile 修饰 ,读就不用加锁</li>
</ul>
<h4 id="多线程下如何确定size"><a href="#多线程下如何确定size" class="headerlink" title="多线程下如何确定size"></a>多线程下如何确定size</h4><ul>
<li><p><strong>1.7</strong> : </p>
<ol>
<li><p>首先他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的</p>
</li>
<li><p>如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回</p>
</li>
</ol>
</li>
<li><p><strong>1.8</strong> : </p>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h3><ul>
<li><p>首先定义一个 Redis 队列名为 sku:awards，里面的元素的值都是比如 1，只是用来代表一个商品，元素的个数则是供秒杀的商品总数。</p>
</li>
<li><p>因为 Redis 是单线程的，所以可以将并发的请求串行化，而且 Redis List 的 pop 操作是原子性的。</p>
</li>
<li><p>所有请求打到 Redis 上，都是从 sku:awards 队列上 pop 出一个元素：</p>
<ol>
<li><p>如果有，说明还有商品，那么需要 把用户ID加入到Redis 的 Set 名为 candidate:userids 里：</p>
<ol>
<li>如果加入成功，说明用户是第一次抢购</li>
<li>否则，说明用户已经成功抢购了，不能重复抢购，需要往队列 sku:awards 弥补一个商品标识元素</li>
</ol>
</li>
<li>没有取到，说明都被秒杀完了</li>
</ol>
</li>
</ul>
<h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p>redis里维护一份库存  使用decr操作减一  然后mq更新数据库</p>
<h3 id="重复支付"><a href="#重复支付" class="headerlink" title="重复支付"></a>重复支付</h3><p>订单状态+redis分布式锁   将订单ID设为key后缀 使锁的级别控制位订单级别  </p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h3><p><a href="https://blog.51cto.com/viphyy/2093535" target="_blank" rel="noopener">linux 常用命令</a></p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="dubbo跟feign区别"><a href="#dubbo跟feign区别" class="headerlink" title="dubbo跟feign区别"></a>dubbo跟feign区别</h3><p><strong>Duoob</strong>:RPC—底层 TCP(TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去)</p>
<p><strong>Feign</strong>:REST—底层 HTTP(HTTP在每次请求结束后都会主动释放连接)</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">kangshifu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="zhangchengkang.top/posts/3617069065.html">zhangchengkang.top/posts/3617069065.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">kangshifu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/面试/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">不会真有人打赏吧?不会吧不会吧</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC8zNzc0OC8xNDI3OQ">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/posts/3617069065.html">
                    <div class="card-image">
                        
                        
                        <img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/matery/featureimages/18.jpg" class="responsive-img" alt="2020-3年面试总结">
                        
                        <span class="card-title">2020-3年面试总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                             
RabbitMQRabbitMQ架构


Message:：消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系 
列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-04-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/面试/" class="post-category">
                                    面试
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/面试/">
                        <span class="chip bg-color">面试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/1644716670.html">
                    <div class="card-image">
                        
                        
                        <img src="https://blog-1257031229.cos.ap-shanghai.myqcloud.com/matery/featureimages/7.jpg" class="responsive-img" alt="责任链模式">
                        
                        <span class="card-title">责任链模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                              
介绍顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
在这种模式中，通常每
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-12-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/设计模式/" class="post-category">
                                    设计模式
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/设计模式/">
                        <span class="chip bg-color">设计模式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('5'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="880742633"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2018</span>
            <a href="/about" target="_blank">kangshifu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">78.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
