---
toc: true
title:  Synchronized
date: 2018-07-12 20:17:13
tags: [Java 并发]
categories: JAVA
---
*Add this line to Using the more label,but it's too short to look bad,addition point length*
<!--more--> 

## 线程安全问题
````
在线程安全性的定义中，最核心的概念就是正确性。当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的。
````

在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个 共享、可变资源 的情况，这种资源可以是：一个变量、一个对象、一个文件等。特别注意两点，
* 共享： 意味着该资源可以由多个线程同时访问
* 可变：意味着该资源可以在其生命周期内被修改
所以，当多个线程访问这种资源的时候，就会存在一个问题:由于每个线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问。
## 如何解决线程安全问题
实际上，所有的并发模式在解决线程安全问题时，采用的方案都是 序列化访问临界资源 。即在同一时刻，只能有一个线程访问临界资源，也称作 同步互斥访问。换句话说，就是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。
##  synchronized 同步方法或者同步块
在了解 synchronized 关键字的使用方法之前，我们先来看一个概念：互斥锁，即 能到达到互斥访问目的的锁。举个简单的例子，如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。

　　在 Java 中，可以使用 synchronized 关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。
* 当一个线程正在访问一个对象的 synchronized 方法，那么其他线程不能访问该对象的其他 synchronized 方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。
