<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>volatile</title>
      <link href="/2018/07/15/volatile/"/>
      <url>/2018/07/15/volatile/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a><br>　  在 Java 并发编程中，要想使并发程序能够正确地执行，必须要保证三条原则，即：原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致程序运行不正确。volatile关键字 被用来保证可见性，即保证共享变量的内存可见性以解决缓存一致性问题。一旦一个共享变量被 volatile关键字 修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。在多线程环境下，volatile关键字 主要用于及时感知共享变量的修改，并使得其他线程可以立即得到变量的最新值，例如，用于 修饰状态标记量 和 Double-Check (双重检查)中。</p><p>　　volatile关键字 虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于 volatile关键字 是与 内存模型 紧密相关，因此在讲述 volatile关键字 之前，我们有必要先去了解与内存模型相关的概念和知识，然后回头再分析 volatile关键字 的实现原理，最后在给出 volatile关键字 的使用场景。</p><h2 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h2><p>　　大家都知道，计算机在执行程序时，每条指令都是在 CPU 中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。<br>　　<br>　　也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p><p>　　当线程执行这个语句时，会先从主存当中读取 i 的值，然后复制一份到高速缓存当中，然后CPU执行指令对 i 进行加1操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。</p><p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p><p>　　比如，同时有两个线程执行这段代码，假如初始时 i 的值为 0，那么我们希望两个线程执行完之后 i 的值变为 2。但是事实会是这样吗？</p><p>　　可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。</p><p>　　最终结果 i 的值是 1，而不是 2 。这就是著名的 缓存一致性问题 。通常称这种被多个线程访问的变量为 共享变量 。</p><p>　　也就是说，如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 缓存不一致 的问题。</p><p>　　为了解决缓存不一致性问题，在 硬件层面 上通常来说有以下两种解决方法：</p><ul><li>通过在 总线加 LOCK# 锁 的方式 （在软件层面，效果等价于使用 synchronized 关键字）；</li><li>通过 缓存一致性协议 （在软件层面，效果等价于使用 volatile 关键字）。</li></ul><p>　　在早期的 CPU 当中，是通过在总线上加 LOCK# 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中， 如果一个线程在执行 i = i + 1，如果在执行这段代码的过程中，在总线上发出了 LCOK# 锁的信号，那么只有等待这段代码完全执行完毕之后，其他 CPU 才能从变量 i 所在的内存读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。但是上面的方式会有一个问题，由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。</p><p>　　所以，就出现了 缓存一致性协议 ，其中最出名的就是 Intel 的 MESI 协议。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是： 当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态。因此，当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 </p><h2 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>原子性</strong>： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>可见性</strong>： 指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>　　举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//线程1执行的代码</span><br><span class="line">int i = 0;</span><br><span class="line">i = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程2执行的代码</span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure></p><p>　　假若执行 线程1 的是 CPU1，执行 线程2 的是 CPU2。由上面的分析可知，当 线程1 执行 i = 10 这句时，会先把 i 的初始值加载到 CPU1 的高速缓存中，然后赋值为10，那么在 CPU1 的高速缓存当中 i 的值变为 10 了，却没有立即写入到主存当中。此时，线程2 执行 j = i，它会先去主存读取 i 的值并加载到 CPU2 的缓存当中，注意此时内存当中 i 的值还是 0，那么就会使得 j 的值为 0，而不是 10。</p><p>　　这就是可见性问题，线程1 对变量 i 修改了之后，线程2 没有立即看到 线程1 修改后的值。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</p><ul><li>指令重排序:处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;    //语句1</span><br><span class="line">int r = 2;    //语句2</span><br><span class="line">a = a + 3;    //语句3</span><br><span class="line">r = a*a;     //语句4</span><br></pre></td></tr></table></figure></li></ul><p>　　这段代码有4个语句，那么可能的一个执行顺序是：2 → 1 → 3 → 4 这就是指令重排序<br>　　那么可不可能是这个执行顺序呢：2 → 1 → 4 → 3<br>　　答案是不可能，因为处理器在进行重排序时会考虑指令之间的<strong>数据依赖性</strong>，如果一个指令 Instruction 2 必须用到 Instruction 1 的结果，那么处理器会保证 Instruction 1 会在 Instruction 2 之前执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>　　上面代码中，由于 语句1 和 语句2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在 线程1 执行过程中先执行 语句2，而此时 线程2 会以为初始化工作已经完成，那么就会跳出 while循环 ，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。</p><p>　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>　　在 Java虚拟机规范 中，试图定义一种 Java内存模型（Java Memory Model，JMM） 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（c/c++）直接使用物理硬件和操作系统的内存模型，因此会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另一套平台上并发访问却经常出错。</p><p>　　Java内存模型 规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</p><p>　　举个简单的例子：在java中，执行下面这个语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = 10;</span><br></pre></td></tr></table></figure></p><p>　　执行线程必须先在自己的工作线程中对 变量i 所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。</p><p>　　这里讲的主内存，工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那主内存对应于Java堆中的对象实例数据 部分，而工作内存则对应于虚拟机栈中的部分区域。</p><h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><p>　　关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成<br><strong>lock(锁定)</strong>： 作用与主内存的变量，它把一个变量标识为一条线程独占的状态。<br><strong>unlock(解锁)</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br><strong>read(读取)</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中<br><strong>load(载入)</strong>：作用于工作内存的变量，它把read操作从主内存得到的变量放入工作内存的变量副本中<br><strong>use(使用)</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作<br><strong>assign(赋值)</strong>：作用于工作内存的变量他把 一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作<br><strong>store(存储)</strong>：作用于 工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用<br><strong>write(写入)</strong>：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>　　由Java内存模型来直接保证原子性变量操作包括 read,load,assign,use,store,write，我们大致可以认为 基本数据类型的访问读写是具备原子性的（读+写就不是了）<br>　　如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>　　对于可见性，Java 提供了 volatile关键字 来保证可见性。<br>　　当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 在释放锁之前会将对变量的修改刷新到主存当中，因此可以保证可见性。</p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>　　Java中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指”线程内 表现为串行的语句”，后半句是指指令重排序现象和工作内存与主内存同步延迟现象<br>　　在 Java 中，可以通过 volatile 关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外，我们千万不能想当然地认为，可以通过synchronized 和 Lock 来保证有序性，也就是说，不能由于 synchronized 和 Lock 可以让线程串行执行同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h3><p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰后，那么就具备了两层语义：</p><ul><li>保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 立即可见 的；</li><li>禁止进行指令重排序，即保证有序性<h3 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//线程类</span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    // volatile 共享静态变量，类成员</span><br><span class="line">    public volatile static int count;</span><br><span class="line"></span><br><span class="line">    private static void addCount() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;count=&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        addCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建 100个线程并启动</span><br><span class="line">        MyThread[] mythreadArray = new MyThread[100];</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            mythreadArray[i] = new MyThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            mythreadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/* Output(循环): </span><br><span class="line">       ... ...</span><br><span class="line">       count=9835</span><br><span class="line"> *///:~</span><br></pre></td></tr></table></figure></li></ul><p>　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是 10000。但是事实上运行它会发现每次运行结果都不一致，都是一个 小于 10000 的数字。可能有的朋友就会有疑问，不对啊，上面是对变量 count 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 count 自增完之后，在其他线程中都能看到修改后的值啊，所以有 100个 线程分别进行了 100 次操作，那么最终 count 的值应该是 100*100=10000。</p><p>　　这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。在前面已经提到过，自增操作是不具备原子性的，它包括 读取变量的原始值、进行加1操作 和 写入工作内存 三个原子操作。那么就是说，这三个子操作可能会分割开执行，所以就有可能导致下面这种情况出现：</p><p>　　假如某个时刻 变量count 的值为 10，线程1 对变量进行自增操作，线程1 先读取了 变量count 的原始值，然后 线程1 被阻塞了；然后，线程2 对变量进行自增操作，线程2 也去读取 变量count 的原始值，由于 线程1 只是对 变量count 进行读取操作，而没有对变量进行修改操作，所以不会导致 线程2 的工作内存中缓存变量 count 的缓存行无效，所以 线程2 会直接去主存读取 count的值 ，发现 count 的值是 10，然后进行加 1 操作。注意，此时 线程2 只是执行了 count + 1 操作，还没将其值写到 线程2 的工作内存中去！此时线程2 被阻塞，线程1 进行加 1 操作时，注意操作数count仍然是 10！然后，线程2 把 11 写入工作内存并刷到主内存。虽然此时 线程1 能感受到 线程2 对count的修改，但由于线程1只剩下对count的写操作了，而不必对count进行读操作了，所以此时 线程2 对count的修改并不能影响到 线程1。于是，线程1 也将 11 写入工作内存并刷到主内存。也就是说，两个线程分别进行了一次自增操作后，count 只增加了 1。</p><h3 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h3><p>　　synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率；而 volatile 关键字在某些情况下性能要优于 synchronized，但是要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。通常来说，使用 volatile 必须具备以下两个条件：</p><ul><li>对变量的写操作不依赖于当前值；</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值 独立于任何程序的状态，包括变量的当前状态。事实上，上面的两个条件就是保证对 该volatile变量 的操作是原子操作，这样才能保证使用 volatile关键字 的程序在并发时能够正确执行。</p><p>特别地，关键字 volatile 主要使用的场合是:</p><p>　　在多线程环境下及时感知共享变量的修改，并使得其他线程可以立即得到变量的最新值。</p><h4 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 示例 1</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 示例 2</span><br><span class="line">volatile boolean inited = false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程1:</span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = true;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">    sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><h4 id="Double-Check-双重检查"><a href="#Double-Check-双重检查" class="headerlink" title="Double-Check (双重检查)"></a>Double-Check (双重检查)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　关键字volatile 与内存模型紧密相关，是线程同步的轻量级实现，其性能要比 synchronized关键字 好。在作用对象和作用范围上， volatile 用于修饰变量，而 synchronized关键字 用于修饰方法和代码块，而且 synchronized 语义范围不但包括 volatile拥有的可见性，还包括volatile 所不具有的原子性，但不包括 volatile 拥有的有序性，即允许指令重排序。因此，在多线程环境下，volatile关键字 主要用于及时感知共享变量的修改，并保证其他线程可以及时得到变量的最新值<br><img src="/img/thread/volatile和synchronized的关系.png" alt="线程生命周期"></p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Synchronized</title>
      <link href="/2018/07/12/Synchronized/"/>
      <url>/2018/07/12/Synchronized/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a> </p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线程安全性的定义中，最核心的概念就是正确性。当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的。</span><br></pre></td></tr></table></figure><p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个 共享、可变资源 的情况，这种资源可以是：一个变量、一个对象、一个文件等。特别注意两点，</p><ul><li>共享： 意味着该资源可以由多个线程同时访问</li><li>可变：意味着该资源可以在其生命周期内被修改<br>所以，当多个线程访问这种资源的时候，就会存在一个问题:由于每个线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问。<h2 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="headerlink" title="如何解决线程安全问题"></a>如何解决线程安全问题</h2>实际上，所有的并发模式在解决线程安全问题时，采用的方案都是 序列化访问临界资源 。即在同一时刻，只能有一个线程访问临界资源，也称作 同步互斥访问。换句话说，就是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。<h2 id="synchronized-同步方法或者同步块"><a href="#synchronized-同步方法或者同步块" class="headerlink" title="synchronized 同步方法或者同步块"></a>synchronized 同步方法或者同步块</h2>在了解 synchronized 关键字的使用方法之前，我们先来看一个概念：互斥锁，即 能到达到互斥访问目的的锁。举个简单的例子，如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。</li></ul><p>　　在 Java 中，可以使用 synchronized 关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p><ul><li>当一个线程正在访问一个对象的 synchronized 方法，那么其他线程不能访问该对象的其他 synchronized 方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Thread</title>
      <link href="/2018/07/08/Thread/"/>
      <url>/2018/07/08/Thread/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a> </p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><table><thead><tr><th style="text-align:left">状态</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">new</td><td style="text-align:left">创建状态—&gt;使用new关键字，创建一个线程,但是还没有调用start方法，仅仅由JVM分配内存，并初始化成员变量</td></tr><tr><td style="text-align:left">runnable/start</td><td style="text-align:left">就緒状态—&gt;调用start()后处于就绪状态，JVM为其创建方法调用栈和程序计数器，但线程并没有开始运行，仅表示可以运行。何时开始，取决于JVM里的线程调度器的调度</td></tr><tr><td style="text-align:left">running</td><td style="text-align:left">运行状态—&gt;处于就绪状态的线程，获得了CPU，开始执行run()方法，则处于运行状态</td></tr><tr><td style="text-align:left">blocked</td><td style="text-align:left">阻塞状态—&gt;表示线程阻塞于锁。线程之间需要切换，时间段用完后，系统会剥夺线程占用的资源，让其他线程执行，选择哪个线程，系统会考虑线程的优先级。调用sleep(),调用阻塞式IO方法，等待同步锁，等待通知wait()，suspend(),join()，这些将使得线程进入阻塞状态</td></tr><tr><td style="text-align:left">waiting</td><td style="text-align:left">等待状态—&gt;进入该状态后需要其他线程做出通知动作，也可以算是阻塞状态。需要notify()唤醒线程，使之进入就绪状态</td></tr><tr><td style="text-align:left">timewaiting</td><td style="text-align:left">超时等状态状态—&gt;该状态与WAITING不同，它是可以在指定时间内自行返回的。相当于在等待状态基础上，增加了时间的限制，超过了设定的时间限制就会返回到运行状态</td></tr><tr><td style="text-align:left">dead/terminated</td><td style="text-align:left">死亡状态—&gt;线程执行完毕。run()或call()执行完成,线程抛出未捕获的Exception或Error，调用该线程的stop()，都会结束线程。</td></tr></tbody></table><p><img src="/img/thread/003.png" alt="线程生命周期"></p><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在Java中，创建线程去执行子任务一般有两种方式：继承Thread类和实现Runnable接口。 其中，Thread类本身就实现了Runnable 接口，而使用继承Therad类的方式创建线程的最大局限就是不支持多继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//线程创建示例代码</span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //使用继承Thread类的方式创建线程</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Thread&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        //使用实现Runnable接口的方式创建线程</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Runnable&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        //JVM 创建的主线程 main</span><br><span class="line">        System.out.println(&quot;main&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run()方法中只是定义需要执行的任务，并且不需要用户来调用。当通过start()方法启动一个线程之后，若线程获得了CPU执行时间，便进入 run()方法去执行具体的任务。如果用户直接调用run()方法相当于在主线程中执行run()方法，跟普通的方法调用没有任何区别。</p><h2 id="Thread类详解"><a href="#Thread类详解" class="headerlink" title="Thread类详解"></a>Thread类详解</h2><p>Thread 类实现了 Runnable 接口，在 Thread 类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。</p><h3 id="start-方法"><a href="#start-方法" class="headerlink" title="start 方法"></a>start 方法</h3><p>start()用来启动一个线程，当调用该方法后，相应线程就会进入就绪状态，该线程中的run()方法会在某个时间被调用</p><h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h3><p>run()方法是不需要用户来调用的。当通过start()方法启动一个线程之后，一旦线程获得了CPU执行时间，便进入run()方法体去执行具体的任务。注意，创建线程是必须要重写run()方法，以定义具体要执行的任务<br><img src="/img/thread/004.png" alt="run方法实现"></p><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>sleep()方法的作用是在指定的毫秒数内让当前正在执行的线程睡眠，并交出CPU让其去执行其他的任务。当线程睡眠时间满后，不一定会立即得到执行，因为此时CPU正在执行其他的任务。所以说，调用sleep方法相当于让线程进入阻塞状态。该方法有如下两条特征：</p><ul><li>如果调用了sleep方法，必须捕获InterruptedException异常或将该异常向上层抛出</li><li>sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象<br><img src="/img/thread/005.png" alt="sleep方法"></li></ul><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>调用yield()方法会让当前线程 交出CPU资源，让CPU去执行 其他 线程，但是，yield()不能控制具体的交出CPU的时间，需要注意的是</p><ul><li>yield()方法只能让拥有相同优先级的线程有获取CPU执行时间的机会</li><li>调用yield()方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，塔只需要等待重新得到CPU的执行<br><img src="/img/thread/006.png" alt="yield实现"></li></ul><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>假如在main线程 中调用thread.join方法，则main线程会等待thread线程执行完毕或者等待一定的时间。详细地，如果调用的是无参join方法，则等待thread执行完毕；如果调用的是指定了时间参数的join方法，则等待一定的时间。join()方法有三个重载版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException &#123;...&#125;</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException &#123;...&#125;</span><br><span class="line">public final synchronized void join(long millis, int nanos) throws InterruptedException &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>以join(long millis) 方法为例，其内部调用了Object的wait方法，如下图<br><img src="/img/thread/007.png" alt="join方法"><br>根据以上源代码可以看出，join()方法是通过wait()方法 (Object 提供的方法) 实现的。当 millis == 0 时，会进入 while(isAlive()) 循环，并且只要子线程是活的，宿主线程就不停的等待。 wait(0) 的作用是让当前线程(宿主线程)等待，而这里的当前线程是指 Thread.currentThread() 所返回的线程。所以，虽然是子线程对象调用wait()方法，但是阻塞的是宿主线程。</p><h3 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h3><p>interrupt,顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就是说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupted()方法和isInterrupted()方法可以停止正在运行的线程。interrupt方法在JDK中的定义为：<br><img src="/img/thread/008.png" alt="interrupt方法"><br>interrupted()和isInterrupted()方法在JDK中的定义分别为：<br><img src="/img/thread/009.png" alt="interrupt方法"></p><h3 id="stop方法"><a href="#stop方法" class="headerlink" title="stop方法"></a>stop方法</h3><p>stop()方法已经是一个废弃的方法，它是一个不安全的方法。因为调用 stop()方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象的话，会完全释放锁，导致对象状态不一致。所以，stop()方法基本是不会被用到的。</p><h3 id="线程暂停-恢复"><a href="#线程暂停-恢复" class="headerlink" title="线程暂停/恢复"></a>线程暂停/恢复</h3><p>暂停线程意味着此线程还可以恢复运行，我们可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行，但是这两个方法已被废弃，因为他们具有固有的死锁倾向。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前，任何线程都不能访问该资源。如果重新开始目标线程的线程想在调用 resume 之前锁定该监视器，则会发生死锁。具体地，在使用 suspend 和 resume 方法时，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法得到公共同步对象锁，从而造成死锁</p><h2 id="线程常用操作"><a href="#线程常用操作" class="headerlink" title="线程常用操作"></a>线程常用操作</h2><h3 id="currentThread方法"><a href="#currentThread方法" class="headerlink" title="currentThread方法"></a>currentThread方法</h3><p>currentThread()方法返回代码正在执行当前代码的线程。其在Thrad类中定义如下:<br><img src="/img/thread/010.png" alt="currentThread方法"></p><h3 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h3><p>isAlve()的功能是判断调用该方法的线程是否处于活动状态。其中，活动状态是指线程已经start（无论是否获得CPU资源并运行）且尚未结束<br><img src="/img/thread/011.png" alt="isAlive方法"></p><h3 id="getId"><a href="#getId" class="headerlink" title="getId"></a>getId</h3><p>getId()作用是获取线程唯一标识，由JVM自动给出<br><img src="/img/thread/012.png" alt="getId方法"></p><h3 id="getName-setName"><a href="#getName-setName" class="headerlink" title="getName/setName"></a>getName/setName</h3><p>用来得到或者设置线程名称。如果我们不手动设置线程的名字，JVM会为该线程自动创建一个表示名，形式为;Thread-数字</p><h3 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h3><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程。设置线程优先级有助于帮助“线程规划器”确定在下一次选择哪个线程 来获得CPU资源。在Java中，线程的优先级分为1~10这十个等级，如果小于1或大于10，则JDK抛出异常IllegalArgumentException,JDK中 使用3个常量来预置定义优先级的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final int MIN_PRIORITY = 1; </span><br><span class="line">public static final int NORM_PRIORITY = 5; </span><br><span class="line">public static final int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure></p><p><img src="/img/thread/013.png" alt="setPriority方法"></p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><h5 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h5><p>在 Java 中，线程的优先级具有继承性，比如 A 线程启动 B 线程， 那么 B 线程的优先级与 A 是一样的。</p><h5 id="规则性和随机性"><a href="#规则性和随机性" class="headerlink" title="规则性和随机性"></a>规则性和随机性</h5><p>线程的优先级具有一定的规则性，也就是CPU尽量将执行资源让给优先级比较高的线程。特别地，高优先级的线程总是大部分先执行完，但并不一定所有的高优先级线程都能先执行完。</p><h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程(Daemon)"></a>守护线程(Daemon)</h3><p>在 Java 中，线程可以分为两种类型，即用户线程和守护线程。守护线程是一种特殊的线程，具有“陪伴”的含义：当进程中不存在非守护线程时，则守护线程自动销毁，典型的守护线程就是垃圾回收线程。任何一个守护线程都是整个JVM中所有非守护线程的保姆，只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作；只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。 在 Thread类中，方法 setDaemon() 的定义为：<br><img src="/img/thread/014.png" alt="setPriority方法"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="对于上述线程的各项基本操作，其-所操作的对象-满足："><a href="#对于上述线程的各项基本操作，其-所操作的对象-满足：" class="headerlink" title="对于上述线程的各项基本操作，其 所操作的对象 满足："></a>对于上述线程的各项基本操作，其 所操作的对象 满足：</h3><ul><li>若该操作是静态方法，也就是说，该方法属于类而非具体的某个对象，那么该操作的作用对象就是 currentThread() 方法所返回 Thread 对象</li><li>若该操作是实例方法，也就是说，该方法属于对象，那么该操作的作用对象就是调用该方法的 Thread 对象。<h3 id="对于上述线程的各项基本操作，有："><a href="#对于上述线程的各项基本操作，有：" class="headerlink" title="对于上述线程的各项基本操作，有："></a>对于上述线程的各项基本操作，有：</h3></li><li>线程一旦被阻塞，就会释放 CPU.</li><li>当线程出现异常且没有捕获处理时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</li><li>对于一个线程，CPU 的释放 与 锁的释放没有必然联系。</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap</title>
      <link href="/2018/07/03/HashMap/"/>
      <url>/2018/07/03/HashMap/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a><br><strong>原理</strong>： hashmap差不多是由链表组成的数组，当添加一个元素（key-value)时，就首先计算元素key的hash值，以此确定插入数组中的位置。当hash值相同时就放在已存在元素的后面形成链表，当链表长度太大时，链表就转换为红黑树。当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中<br><img src="/img/se/001.jpg" alt="hashMap存储结构"> </p><h2 id="JDK1-8中的涉及到的数据结构"><a href="#JDK1-8中的涉及到的数据结构" class="headerlink" title="JDK1.8中的涉及到的数据结构"></a>JDK1.8中的涉及到的数据结构</h2><h3 id="位桶数组"><a href="#位桶数组" class="headerlink" title="位桶数组"></a>位桶数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;k,v&gt;[] table;//存储（位桶）的数组&lt;/k,v&gt;</span><br></pre></td></tr></table></figure><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Node是单向链表，它实现了Map.Entry接口</span><br><span class="line">static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;k,v&gt; next;</span><br><span class="line"></span><br><span class="line">    //构造函数Hash值 键 值 下一个节点</span><br><span class="line">    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + = + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;</span><br><span class="line">    TreeNode&lt;k,v&gt; parent;  // 父节点</span><br><span class="line">    TreeNode&lt;k,v&gt; left; //左子树</span><br><span class="line">    TreeNode&lt;k,v&gt; right;//右子树</span><br><span class="line">    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;    //颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //返回当前节点的根节点</span><br><span class="line">    final TreeNode&lt;k,v&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap的构造函数"><a href="#HashMap的构造函数" class="headerlink" title="HashMap的构造函数"></a>HashMap的构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    //指定的初始容量非负</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(Illegal initial capacity: initialCapacity);</span><br><span class="line">    //如果指定的初始容量大于最大容量,置为最大容量</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    //填充比为正</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(Illegal load factor:  +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);//新的扩容临界值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//构造函数2</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//构造函数3</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//构造函数4用m的元素初始化散列映射</span><br><span class="line">public HashMap(Map&lt;!--? extends K, ? extends V--&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h2><h3 id="HashMap如何getvalue值"><a href="#HashMap如何getvalue值" class="headerlink" title="HashMap如何getvalue值"></a>HashMap如何getvalue值</h3><p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  /**</span><br><span class="line">     * Implements Map.get and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @return the node, or null if none</span><br><span class="line">     */</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;//Entry对象数组</span><br><span class="line">Node&lt;K,V&gt; first,e; //在tab数组中经过散列的第一个位置</span><br><span class="line">int n;</span><br><span class="line">K k;</span><br><span class="line">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span><br><span class="line">//也就是说在一条链上的hash值相同的</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">/*检查第一个Node是不是要找的Node*/</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//判断条件是hash值要相同，key值要相同</span><br><span class="line">                return first;</span><br><span class="line">  /*检查first后面的node*/</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="HashMap如何put（key-value"><a href="#HashMap如何put（key-value" class="headerlink" title="HashMap如何put（key,value)"></a>HashMap如何put（key,value)</h3><ul><li>判断键值对数组tab[]是否为空或为null，否则以默认大小resize()；</li><li>根据键值key计算hash值得到插入的数组索引i，如果tab[i]==null，直接新建节点添加，否则转入3</li><li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"> /**</span><br><span class="line">     * Implements Map.put and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @param value the value to put</span><br><span class="line">     * @param onlyIfAbsent if true, don&apos;t change existing value</span><br><span class="line">     * @param evict if false, the table is in creation mode.</span><br><span class="line">     * @return previous value, or null if none</span><br><span class="line">     */</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; </span><br><span class="line">Node&lt;K,V&gt; p; </span><br><span class="line">int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">/*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">/*表示有冲突,开始处理冲突*/</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; </span><br><span class="line">    K k;</span><br><span class="line">/*检查第一个Node，p是不是要找的值*/</span><br><span class="line">            if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">/*指针为空就挂在后面*/</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">       //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　　　　　　　　</span><br><span class="line">　　　　　　　　　　　　//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行</span><br><span class="line">                        //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">/*如果有相同的key值就结束遍历*/</span><br><span class="line">                    if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">/*就是链表上有相同的key值*/</span><br><span class="line">            if (e != null) &#123; // existing mapping for key，就是key的Value存在</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;//返回存在的Value值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">     /*如果当前大小大于门限，门限原本是初始容量*0.75*/</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();//扩容两倍</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap的扩容机制resize"><a href="#HashMap的扩容机制resize" class="headerlink" title="HashMap的扩容机制resize()"></a>HashMap的扩容机制resize()</h2><p>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比*Node.length）容量的0.75时,重新调整HashMap大小 变为原来2倍大小,扩容很耗时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line"></span><br><span class="line">/*如果旧表的长度不是空*/</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">/*把新表的长度设置为旧表长度的两倍，newCap=2*oldCap*/</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      /*把新表的门限设置为旧表门限的两倍，newThr=oldThr*2*/</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">     /*如果旧表的长度的是0，就是说第一次初始化表*/</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;//新表长度乘以加载因子</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">/*下面开始构造新表，初始化表中的数据*/</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;//把新表赋值给table</span><br><span class="line">        if (oldTab != null) &#123;//原表不是空要把原表中数据移动到新表中</span><br><span class="line">            /*遍历原来的旧表*/</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)//说明这个node没有链表直接放在新表的e.hash &amp; (newCap - 1)位置</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">/*如果e后边有链表,到这里表示e后面带着个单链表，需要遍历单链表，将每个结点重*/</span><br><span class="line">                    else &#123; // preserve order保证顺序</span><br><span class="line">////新计算在新表的位置，并进行搬运</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;//记录下一个结点</span><br><span class="line">  //新表是旧表的两倍容量，实例上就把单链表拆分为两队，</span><br><span class="line">　　　　　　　　　　　　　　//e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line"></span><br><span class="line">                        if (loTail != null) &#123;//lo队不为null，放在新表原位置</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;//hi队不为null，放在新表j+oldCap位置</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8使用红黑树的改进"><a href="#JDK1-8使用红黑树的改进" class="headerlink" title="JDK1.8使用红黑树的改进"></a>JDK1.8使用红黑树的改进</h2><p>在jdk8中，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8个），采用红黑树存储</p><ul><li>有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储<br><img src="/img/se/001.jpg" alt="红黑树"> </li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建造者模式</title>
      <link href="/2018/06/21/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/21/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="1-重叠构造器模式"><a href="#1-重叠构造器模式" class="headerlink" title="1. 重叠构造器模式"></a>1. 重叠构造器模式</h2><p>在这种模式下,我们提供的第一个构造器只有必要的参数,第二个构造器有一个可选参数,第三个构造器有两个可选参数,以此类推,最后一个构造器含有所有参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;    // required</span><br><span class="line">    private String sex;     // required</span><br><span class="line">    private Date date;      // required</span><br><span class="line">    private String email;       // required</span><br><span class="line"></span><br><span class="line">    private int height;     // optional</span><br><span class="line">    private String edu;     // optional</span><br><span class="line">    private String nickName;     // optional</span><br><span class="line">    private int weight;     // optional</span><br><span class="line">    private String addr;     // optional</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email) &#123;</span><br><span class="line">        this(name, sex, date, email, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email, int height) &#123;</span><br><span class="line">        this(name, sex, date, email, height, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email, int height, String edu) &#123;</span><br><span class="line">        this(name, sex, date, email, height, edu, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email, int height, String edu, String nickName) &#123;</span><br><span class="line">        this(name, sex, date, email, height, edu, nickName, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email, int height, String edu, String nickName, int</span><br><span class="line">            weight) &#123;</span><br><span class="line">        this(name, sex, date, email, height, edu, nickName, weight, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, String sex, Date date, String email, int height, String edu, String nickName, int</span><br><span class="line">            weight, String addr) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">        this.date = date;</span><br><span class="line">        this.email = email;</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.edu = edu;</span><br><span class="line">        this.nickName = nickName;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">        this.addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用这种模式创建对象时,存在以下几点不足</p><ul><li><p><strong>灵活性很差</strong> : 如果客户端只想创建一个给定姓名,性别,生日,邮箱和体重,那么他将被迫调用如下构造函数,这样无意中就”被迫”设置了他本不想设置的一些参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, String sex, Date date, String email, int height, String edu, String nickName, int</span><br><span class="line">            weight) &#123;</span><br><span class="line">        this(name, sex, date, email, height, edu, nickName, weight, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码难以编写与阅读</strong> : 当属性有很多的时候,代码不但看起来很丑陋,而且极易出错。试想,若客户端不小心颠倒了两个参数的顺序,编译器也不会出错,但是在运行时就会出现错误的行为,并且这种错误难以发现</p><h2 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2. JavaBeans模式"></a>2. JavaBeans模式</h2><p>这时,我们可能转而求助于JavaBeans模式来避免这些问题,但是同时会带来一些新的问题。</p></li><li><strong>Setter的存在妨碍的其成为不可变类的可能</strong>: 这样,在并发环境下,我们就不得不考虑其线程安全性;</li><li><strong>代码丑陋且对象易处于不一致状态</strong>: 上面创建对象的方式毕竟丑陋,同时由于对象的构造过程分为若干个函数调用,所以容易导致对象处于不一致状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = new Person();</span><br><span class="line">   p2.setName(&quot;zck&quot;);</span><br><span class="line">   p2.setSex(&quot;boy&quot;);</span><br><span class="line">   p2.setDate(new Date());</span><br><span class="line">   p2.setEmail(&quot;*******@qq.com&quot;);</span><br><span class="line">   p2.setHeight(179);</span><br><span class="line">   p2.setEdu(&quot;NCU&quot;);</span><br><span class="line">   p2.setNickName(&quot;kang&quot;);</span><br><span class="line">   p2.setWeight(140);</span><br><span class="line">   p2.setAddr(&quot;武汉市&quot;);</span><br><span class="line">   System.out.println(p2);</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3. Builder模式"></a>3. Builder模式</h2><p>使用Builder模式创建复杂对象,既能保证像重叠构造器模式那样的安全性,也能保证像JavaBeans模式那么好的可读性。该模式的内涵是:不直接生成想要的对象,而是让客户端利用所有必要的参数构造一个Bulider对象,然后在此基础上,调用类似于Setter的方法来设置每个可选参数,最后通过调用无参的build()方法来生成不可变对象。一般的,所属Builder是它所构建类的静态成员类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private final String name;// required</span><br><span class="line">    private final Boolean sex;</span><br><span class="line">    private final Integer age;</span><br><span class="line"></span><br><span class="line">    private final Integer height;// optional</span><br><span class="line">    private final Double weight;</span><br><span class="line">    private final Date birthday;</span><br><span class="line">    private final String addr;</span><br><span class="line"></span><br><span class="line">    private Person(Builder builder) &#123;</span><br><span class="line">        this.name = builder.name;</span><br><span class="line">        this.sex = builder.sex;</span><br><span class="line">        this.age = builder.age;</span><br><span class="line">        this.height =builder.height;</span><br><span class="line">        this.weight = builder.weight;</span><br><span class="line">        this.birthday = builder.birthday;</span><br><span class="line">        this.addr = builder.addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private final String name;</span><br><span class="line">        private final Boolean sex;</span><br><span class="line">        private final Integer age;</span><br><span class="line"></span><br><span class="line">        private Integer height;</span><br><span class="line">        private Double weight;</span><br><span class="line">        private Date birthday;</span><br><span class="line">        private String addr;</span><br><span class="line"></span><br><span class="line">        public Builder(String name, Boolean sex, Integer age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回Builder对象本身，链式调用</span><br><span class="line">        public Builder height(Integer height) &#123;</span><br><span class="line">            this.height = height;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder weight(Double weight) &#123;</span><br><span class="line">            this.weight = weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder birthday(Date birthday) &#123;</span><br><span class="line">            this.birthday = birthday;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder addr(String addr) &#123;</span><br><span class="line">            this.addr = addr;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 通过Builder构建所需Person对象，并且每次都产生新的Person对象</span><br><span class="line">        public Person build() &#123;</span><br><span class="line">            return new Person(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以通过下面的方式来创建一个Person对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.Builder builder = new Person.Builder(&quot;老张&quot;,true,23);</span><br><span class="line">        Person person = builder.addr(&quot;武汉市江夏区&quot;).birthday(new Date(2008,8,8)).height(179).weight(140D).build();</span><br></pre></td></tr></table></figure></p><ul><li><strong>Person类的构造方法是私有的</strong>: 也就是说,客户端不能直接创建Person对象;</li><li><strong>Person类是不可变的</strong>: 所有的属性都被final修饰,在构造方法中设置参数值,并且不对外提供Setter方法</li><li><strong>Bulider模式的高可读性</strong>: Builder模式使用了链式调用,可读性更佳。</li><li><strong>Builder对象与目标对象的异同</strong>: Person与Buildr拥有共同的属性,并且Builder内部类的构造方法中只接收必传的参数,同时只有这些必传的参数使用final修饰符</li></ul><h2 id="4-Builder模式中的参数约束与线程安全行"><a href="#4-Builder模式中的参数约束与线程安全行" class="headerlink" title="4. Builder模式中的参数约束与线程安全行"></a>4. Builder模式中的参数约束与线程安全行</h2><p>Person对象是不可变的,因此是线程安全;但是,Builder对象并不具有线程安全性。因此,当我们需要对Person对象的参数强加约束条件时,我们应该可以对builder()方法中所创建出来的Person对象进行校验,即我们可以将builder()方法进行如下重写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Person build()&#123;</span><br><span class="line">        Person person = new Person(this);</span><br><span class="line">        if (!&quot;boy&quot;.equals(person.sex))&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;所注册用户必须为男性！&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return person;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>需要特别主要的是,我们是对Person对象进行参数检查,而不是对Builder对象进行参数检查,因为Builder对象不是线程安全的,即下面的代码存在线程安全问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Person build()&#123;</span><br><span class="line">        if (!&quot;boy&quot;.equals(this.sex))&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;所注册用户必须为男性！&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new Person(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>接口和抽象类</title>
      <link href="/2018/06/06/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2018/06/06/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a> </p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象。同时，所有的对象都是通过类来描述的，但是并不是所有的类都是可以描述对象（对象 = 状态 + 行为）的。如果一个类没有足够的信息来描述一个具体的对象，那么我们就可以将这样的类设为抽象类。抽象类只能被public和默认修饰符修饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//抽象方法是一种特殊的方法：它只有声明，而没有具体的实现</span><br><span class="line">abstract void func();</span><br></pre></td></tr></table></figure></p><p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类,特别需要注意的是，抽象类也可以不包含抽象方法，即其中所有的方法都是具体方法。<br>因为抽象类中含有未具体实现的方法，所以不能用抽象类创建对象。抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情<br>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><ul><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>抽象类不能用来创建对象；</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ul><p>抽象类比具体类仅多一点抽象因素：行为层面的抽象（可以包含抽象方法）；</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。接口只能被public和默认修饰符修饰。 在Java中，定义一个接口的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceName &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中可以含有 变量和方法。但是要注意，接口中的 变量 会被隐式地指定为 public static final变量并且只能是public static final变量),而 方法 会被隐式地指定为 public abstract方法且只能是 public abstract 方法,且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><h3 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h3><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract (可省) 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final (可省) 类型的；</li><li>抽象类可以有静态代码块和静态方法,接口中不能含有静态代码块以及静态方法;</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br><img src="/img/se/接口抽象类区别.png" alt="接口抽象类区别"></li></ul><h3 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h3><ul><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范(契约)，它可以跨越不同的类，是一种辐射式设计。</li><li>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对象克隆</title>
      <link href="/2018/06/01/%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/"/>
      <url>/2018/06/01/%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Teacher teacher = new Teacher();</span><br><span class="line">Teacher cloneTea = teacher;</span><br><span class="line">cloneTea.setSalary(3000);</span><br><span class="line">System.out.println(&quot;teacher: &quot;+teacher);</span><br><span class="line">System.out.println(&quot;cloneTea: &quot;+cloneTea);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">teacher: Teacher&#123;salary=3000&#125;</span><br><span class="line">cloneTea: Teacher&#123;salary=3000&#125;</span><br><span class="line">//Teacher cloneTea = teacher这句话只是将引用赋值</span><br></pre></td></tr></table></figure><h2 id="1-浅克隆。"><a href="#1-浅克隆。" class="headerlink" title="1. 浅克隆。"></a>1. 浅克隆。</h2><ul><li>浅克隆：只复制基本类型的数据，引用类型的数据只复制了引用的地址</li><li>实现 : 被复制的类实现Clonenable接口,覆盖clone()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;//实现Cloneable接口</span><br><span class="line">    private Integer number;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *重写clone方法(Object里clone方法是protect修饰的)</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        Student student = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            student = (Student) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student1 = new Student();</span><br><span class="line">        student1.setNumber(200);</span><br><span class="line">        Student student2 = (Student) student1.clone();</span><br><span class="line">        System.out.println(student1==student2);</span><br><span class="line">        System.out.println(&quot;student1:&quot; + student1);</span><br><span class="line">        System.out.println(&quot;student2:&quot; + student2);</span><br><span class="line">        student2.setNumber(500);</span><br><span class="line">        System.out.println(&quot;student1:&quot; + student1);</span><br><span class="line">        System.out.println(&quot;student2:&quot; + student2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false//地址不一样了哦</span><br><span class="line">student1:Student&#123;number=200&#125;</span><br><span class="line">student2:Student&#123;number=200&#125;</span><br><span class="line">student1:Student&#123;number=200&#125;</span><br><span class="line">student2:Student&#123;number=500&#125;</span><br></pre></td></tr></table></figure><p>但是如果Student类的属性是另外一个类的话,就会出现新的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Teacher teacher = new Teacher(&quot;武昌&quot;);</span><br><span class="line">    Student student1 = new Student();</span><br><span class="line">    student1.setTeacher(teacher);</span><br><span class="line">    Student student2 = (Student) student1.clone();</span><br><span class="line">    System.out.println(student1 == student2);</span><br><span class="line">    System.out.println(&quot;student1:&quot; + student1);</span><br><span class="line">    System.out.println(&quot;student2:&quot; + student2);</span><br><span class="line">    student2.getTeacher().setAddress(&quot;江夏&quot;);</span><br><span class="line">    System.out.println(&quot;student1:&quot; + student1);</span><br><span class="line">    System.out.println(&quot;student2:&quot; + student2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">student1:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;武昌&apos;&#125;&#125;</span><br><span class="line">student2:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;武昌&apos;&#125;&#125;</span><br><span class="line">student1:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;江夏&apos;&#125;&#125;</span><br><span class="line">student2:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;江夏&apos;&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个address都变了<br>稍微修改一行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student2.setTeacher(new Teacher(&quot;汉口&quot;));</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">student1:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;武昌&apos;&#125;&#125;</span><br><span class="line">student2:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;武昌&apos;&#125;&#125;</span><br><span class="line">student1:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;武昌&apos;&#125;&#125;</span><br><span class="line">student2:Student&#123;number=null, teacher=Teacher&#123;salary=null, address=&apos;汉口&apos;&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以发现student1的address没变<br>显而易见,浅克隆中属性如果是一个类的话,那么复制的是这个类的地址</p><h2 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2. 深克隆"></a>2. 深克隆</h2><ul><li>深克隆: 是在引用类型的类中也实现了clone，是clone的嵌套，复制后的对象与原对象之间完全不会影响。</li><li>实现 : 不仅需要将被复制的类实现Clonenable接口,覆盖clone()方法而且该类中的某个类型为类的属性也需要被复制的话那这个类也需要实现Clonenable接口,覆盖clone()方法;</li><li>如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用clone方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。</li></ul><h2 id="3-使用序列化的方式解决多层克隆"><a href="#3-使用序列化的方式解决多层克隆" class="headerlink" title="3. 使用序列化的方式解决多层克隆"></a>3. 使用序列化的方式解决多层克隆</h2><ul><li>使用序列化也能完成深复制的功能：对象序列化后写入流中，此时也就不存在引用什么的概念了，再从流中读取，生成新的对象，新对象和原对象之间也是完全互不影响的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Teacher teacher = new Teacher();</span><br><span class="line">        teacher.setAddress(&quot;西湖&quot;);</span><br><span class="line">        Teacher teacher1 = (Teacher) cloneObj(teacher);</span><br><span class="line">        System.out.println(teacher==teacher1);</span><br><span class="line">        System.out.println(&quot;teacher:&quot;+teacher);</span><br><span class="line">        System.out.println(&quot;teacher1:&quot;+teacher1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object cloneObj(Teacher teacher) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = new ObjectOutputStream(byteOut);</span><br><span class="line">        objOut.writeObject(teacher);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">        ObjectInputStream objIn = new ObjectInputStream(byteIn);</span><br><span class="line">       return objIn.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">teacher:Teacher&#123;salary=null, address=&apos;西湖&apos;&#125;</span><br><span class="line">teacher1:Teacher&#123;salary=null, address=&apos;西湖&apos;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式</title>
      <link href="/2018/05/31/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/05/31/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="1-简单工厂模式（SimpleFactory-Mode）"><a href="#1-简单工厂模式（SimpleFactory-Mode）" class="headerlink" title="1. 简单工厂模式（SimpleFactory Mode）"></a>1. 简单工厂模式（SimpleFactory Mode）</h2><p>　　简单工厂模式的思路是，首先我们把一些共性的东西（算法）拿出来，进行抽象，比如加减乘除。然后我们在定义一个类作为工厂类，工厂类的作用就是根据传过来的字符串或者其他Key值给返回一个相对应的算法的实体。<br><img src="/img/设计模式/工厂模式/简单工厂模式.png" alt="简单工厂模式"></p><ul><li><strong>原理</strong> : 一个具体工厂通过条件语句创建多个产品，产品的创建逻辑集中于一个工厂类,客户端通过传不同的参数给工厂，实现创建不同产品的目的</li><li><strong>优点</strong> : 客户端不知道产品的实现细节,降低耦合</li><li><strong>缺点</strong> : 增加新产品时需要修改工厂类,不同的产品都在同一个工厂生产,并没有完全解耦</li></ul><h2 id="2-工厂方法模式（Factory-Method）"><a href="#2-工厂方法模式（Factory-Method）" class="headerlink" title="2. 工厂方法模式（Factory Method）"></a>2. 工厂方法模式（Factory Method）</h2><p>　　定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br><img src="/img/设计模式/工厂模式/工厂方法模式.png" alt="工厂方法模式"></p><ul><li><strong>原理</strong> : 一个工厂创建一个产品，所有的具体工厂继承自一个抽象工厂。客户端先创建不同产品的工厂，再由工厂创建具体产品，产品的创建逻辑分散在每个具体工厂类中。</li><li><strong>优点</strong> :　增加新产品时不需要去修改抽象工厂了，符合OCP原则（开闭原则）</li><li><strong>缺点</strong> : 子类工厂会很多,不利于维护</li></ul><h2 id="3-抽象工厂模式（Abstract-Factory）"><a href="#3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="3. 抽象工厂模式（Abstract Factory）"></a>3. 抽象工厂模式（Abstract Factory）</h2><p>　　首先是满足OCP的，而且可以满足产品切换，能实现的前提是比如A和B两个产品，它们有1和2两个方法接口（类），现在我们在增加新的产品C（假设也是只有1和2两个方法接口），我们要做的只是增加一个产品类再增加一个工厂类就行了，如果是简单工厂或者是工厂方法的的话通常都是增加两个算法类C.1,C.2，简单工厂需要修改switch增加两个语句，工厂方法是在增加两个工厂类。可见抽象工厂的优点。<br><img src="/img/设计模式/工厂模式/抽象工厂模式.png" alt="抽象工厂模式"></p><ul><li><strong>原理</strong> :一个具体工厂创建一个产品族，一个产品族是不同系列产品的组合，产品的创建的逻辑分在在每个具体工厂类中。所有的具体工厂继承自同一个抽象工厂。客户端创建不同产品族的工厂，产品族的工厂创建具体的产品对客户端是不可见的。</li><li><strong>优点</strong> :　增加新的产品族时，只需要增加具体工厂类,符合OCP原则</li><li><strong>缺点</strong> : 太重了</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类的实例化</title>
      <link href="/2018/05/30/%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
      <url>/2018/05/30/%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>　在Java中，一个对象在可以被使用之前必须要被正确地初始化，这一点是Java规范规定的。在实例化一个对象时，JVM首先会检查相关类型是否已经加载并初始化，如果没有，则JVM立即进行加载并调用类构造器完成类的初始化。在类初始化过程中或初始化完毕后，根据具体情况才会去对类进行实例化。一个Java对象的创建过程往往包括<strong>类初始化</strong>和<strong>类实例化</strong>两个阶段。</p><h2 id="1-Java对象创建时机"><a href="#1-Java对象创建时机" class="headerlink" title="1 Java对象创建时机"></a>1 Java对象创建时机</h2><p>　　我们知道，一个对象在可以被使用之前必须要被正确地实例化。在Java代码中，有很多行为可以引起对象的创建，最为直观的一种就是使用new关键字来调用一个类的构造函数显式地创建对象，这种方式在Java规范中被称为 : <strong>由执行类实例创建表达式而引起的对象创建</strong>。除此之外，我们还可以使用反射机制(Class类的newInstance方法、使用Constructor类的newInstance方法)、使用Clone方法、使用反序列化等方式创建对象。</p><h3 id="1-1-使用new关键字创建对象"><a href="#1-1-使用new关键字创建对象" class="headerlink" title="1.1 使用new关键字创建对象"></a>1.1 使用new关键字创建对象</h3><p>　　这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们可以调用任意的构造函数（无参的和有参的）去创建对象。：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Object();</span><br></pre></td></tr></table></figure></p><h3 id="1-2-使用Class类的newInstance方法-反射机制"><a href="#1-2-使用Class类的newInstance方法-反射机制" class="headerlink" title="1.2 使用Class类的newInstance方法(反射机制)"></a>1.2 使用Class类的newInstance方法(反射机制)</h3><p>　　我们也可以通过Java的反射机制使用Class类的newInstance方法来创建对象，事实上，这个newInstance方法是调用无参的构造器创建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　Student student = (Student)Class.forName(&quot;Student类全限定名&quot;).newInstance();　</span><br><span class="line">//或者</span><br><span class="line">　　Student stu = Student.class.newInstance();</span><br></pre></td></tr></table></figure></p><h3 id="1-3-使用Constructor类的newInstance方法-反射机制"><a href="#1-3-使用Constructor类的newInstance方法-反射机制" class="headerlink" title="1.3 使用Constructor类的newInstance方法(反射机制)"></a>1.3 使用Constructor类的newInstance方法(反射机制)</h3><p>　　java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象，该方法和Class类中的newInstance方法很像，但是相比之下，Constructor类的newInstance方法更加强大些，我们可以通过这个newInstance方法调用有参数的和私有的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Student(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>使用newInstance方法的这两种方式创建对象使用的就是Java的反射机制，事实上Class的newInstance方法内部调用的也是Constructor的newInstance方法</li></ul><h3 id="1-4-使用clone方法创建对象"><a href="#1-4-使用clone方法创建对象" class="headerlink" title="1.4 使用clone方法创建对象"></a>1.4 使用clone方法创建对象</h3><p>　　无论何时我们调用一个对象的clone方法，JVM都会帮我们创建一个新的、一样的对象，特别需要说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。要想使用clone方法，我们就必须先实现Cloneable接口并实现其定义的clone方法，这也是原型模式的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Child implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    public Child() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public Object clone()&#123;</span><br><span class="line">        Child child = null</span><br><span class="line">        try &#123;</span><br><span class="line">            child  = (Child) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Constructor&lt;Child&gt; childConstructor = Child.class.getConstructor();</span><br><span class="line">        Child child = childConstructor.newInstance();</span><br><span class="line">        Child cloneChild = (Child) child.clone();</span><br><span class="line">        System.out.println(cloneChild==child);//false </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-5-使用-反-序列化机制创建对象"><a href="#1-5-使用-反-序列化机制创建对象" class="headerlink" title="1.5 使用(反)序列化机制创建对象"></a>1.5 使用(反)序列化机制创建对象</h3><p>　　当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Child implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Child child = new Child();</span><br><span class="line">        //写对象</span><br><span class="line">        ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;aaa&quot;));</span><br><span class="line">        output.writeObject(child);</span><br><span class="line">        output.close();</span><br><span class="line">        //读对象</span><br><span class="line">        ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;aaa&quot;));</span><br><span class="line">        Child c = (Child) input.readObject();</span><br><span class="line">        System.out.println(child);//cn.zck.jvm.Child@6d6f6e28</span><br><span class="line">        System.out.println(c);//cn.zck.jvm.Child@7ba4f24f</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Java对象创建过程"><a href="#2-Java对象创建过程" class="headerlink" title="2 Java对象创建过程"></a>2 Java对象创建过程</h2><p>　　当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间)。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。在内存分配完成之后，Java虚拟机就会开始对新创建的对象按照程序猿的意志进行初始化。在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 <strong>实例变量初始化</strong>、<strong>实例代码块初始化</strong> 以及 <strong>构造函数初始化</strong>。<br>　　在编译生成的字节码中，构造函数会被命名成<init>()方法，参数列表与Java语言书写的构造函数的参数列表相同。<br>　　我们知道，Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。事实上，这一点是在构造函数中保证的：Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象<strong>构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数</strong>，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Parent &#123;</span><br><span class="line">    private Integer a;</span><br><span class="line">    private String b;</span><br><span class="line">    private Date c;</span><br><span class="line">    private Double d;</span><br><span class="line"></span><br><span class="line">    public Parent() &#123;</span><br><span class="line">        this(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Parent(int a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">        this();//Call to &apos;this()&apos; must be first statement in constructor body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Parent(String b) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this();//Call to &apos;this()&apos; must be first statement in constructor body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Parent(Date c) &#123;</span><br><span class="line">        this();</span><br><span class="line">        super();//Call to &apos;super()&apos; must be first statement in constructor body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Parent(Double d) &#123;</span><br><span class="line">        //会自动生成super()</span><br><span class="line">        this.d = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></init></p><ul><li>总而言之，实例化一个类的对象的过程是一个典型的递归过程,进一步地说，在实例化一个类的对象时，具体过程是这样的：<blockquote><p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各l进行实例化，直到完成对目标类的实例化。<br>具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象实例化过程</span><br><span class="line">public Child(int a, String b)&#123;</span><br><span class="line">        super();</span><br><span class="line">       // 实例变量或实例代码块</span><br><span class="line">       // 构造函数本身代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="/img/jvm/jvm012.png" alt="实例化一个类的递归过程"></p><p>　　总的来说，类实例化的一般过程是：父类的类构造器&lt;clinit>() -&gt; 子类的类构造器&lt;clinit>() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数&lt;init>() -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数&lt;init>()。</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java垃圾回收机制</title>
      <link href="/2018/05/28/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/05/28/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java技术体系中所提倡的<strong>自动内存管理</strong>最终可以归结为自动化地解决了两个问题：<strong>给对象分配内存</strong>以及<strong>回收分配给对象的内存</strong>，而且这两个问题针对的内存区域就是Java内存模型中的堆区和方法区,但主要是堆(栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作,每一个栈帧中分配多少内存基本上是在类结构确定下来是就已知的,而随着方法结束或线程结束,内存就自然跟着回收了,因此栈区的内存分配和回收都具备确定性。)。</li><li>垃圾回收(Carbage Collection)机制可以有效的防止内存泄露(内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度),保证内存的有效使用,那么GC到底需要做什么呢<blockquote><p>那些内存需要回收?<br>什么时候回收?<br>如何回收?</p></blockquote></li><li>在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：Stop-the-World。Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。</li></ul><h2 id="1-对象已死吗"><a href="#1-对象已死吗" class="headerlink" title="1. 对象已死吗"></a>1. 对象已死吗</h2><p>在堆里面存放着Java世界几乎所有的对象实例,垃圾收集器在堆进行回收前,第一件事情就是要确定这些对象之中哪些还”存活”着,哪些已经”死去”(即不可能再被任何途径使用的对象)</p><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h3><p>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收</p><ul><li><strong>实现</strong>: 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器就加1,当引用失效时,计数器就减1.任何时刻计数器为0的对象就是不可能再被使用的,即能被当做垃圾收集。</li><li><strong>优点</strong>: 效率高,可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利</li><li><strong>缺点</strong>: 很难解决对象之间相互循环引用的问题</li></ul><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><ul><li><strong>实现</strong>: 通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种：<blockquote><p>虚拟机栈(栈帧中的局部变量表)中引用的对象；<br>本地方法栈中Native方法引用的对象；<br>方法区中类静态属性引用的对象；<br>方法区中常量引用的对象；<br><img src="/img/jvm/jvm006.jpg" alt="可达性分析算法示意图"></p></blockquote></li></ul><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2 垃圾收集算法"></a>2 垃圾收集算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><ul><li><strong>实现</strong>: 标记-清除算法分为标记和清除两个阶段。首先标记出所有需要回收的对象,在标记完成后统一回收所标记的对象.</li><li><strong>缺点</strong>: 一个是效率问题,标记和清除的效率都不高,二是空间问题,标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="/img/jvm/jvm009.JPG" alt="标记-清除算法"></li></ul><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><ul><li><strong>实现</strong>: 复制算法将可用内存按容量划分为大小相r等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li><strong>缺点</strong>: 将内存缩小为了原来的一半,对象存活率较高时就要进行较多的复制操作，效率将会变低。<br><img src="/img/jvm/jvm010.JPG" alt="复制算法"></li></ul><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><ul><li><strong>实现</strong>:标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代）<br><img src="/img/jvm/jvm011.JPG" alt="标记-整理算法"></li></ul><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><ul><li>对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：<strong>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。</strong>当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：<br><img src="/img/jvm/jvm007.jpg" alt="分代收集算法总"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</span><br><span class="line"></span><br><span class="line">Full GC：也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</span><br></pre></td></tr></table></figure><h4 id="2-4-1-新生代（Young-Generation）"><a href="#2-4-1-新生代（Young-Generation）" class="headerlink" title="2.4.1 新生代（Young Generation）"></a>2.4.1 新生代（Young Generation）</h4><ul><li>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。</li><li>新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</li></ul><h4 id="2-4-2-老年代（Old-Generation）"><a href="#2-4-2-老年代（Old-Generation）" class="headerlink" title="2.4.2 老年代（Old Generation）"></a>2.4.2 老年代（Old Generation）</h4><ul><li>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次(大概15)垃圾回收后仍然存活的对象就会被放到老年代中</li><li>老年代的内存也比新生代大很多(大概比例是2:1)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</li></ul><h4 id="2-4-3-永久代（Permanent-Generation）"><a href="#2-4-3-永久代（Permanent-Generation）" class="headerlink" title="2.4.3 永久代（Permanent Generation）"></a>2.4.3 永久代（Permanent Generation）</h4><ul><li>永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</li></ul><h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3 垃圾收集器"></a>3 垃圾收集器</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。<br><img src="/img/jvm/jvm008.jpg" alt="垃圾收集器"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><h2 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4 内存分配与回收策略"></a>4 内存分配与回收策略</h2><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存 以及 回收分配给对象的内存。一般而言，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存(TLAB)，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。总的来说，内存分配规则并不是一层不变的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><ul><li><strong>对象优先在Eden分配</strong>: 当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后处理掉Eden和刚才的Survivor空间。（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）当Survivor空间不够用时，需要依赖老年代进行分配担保。</li><li><strong> 大对象直接进入老年代</strong>: 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</li><li><strong> 长期存活的对象将进入老年代</strong>: 当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</li><li><strong> 动态对象年龄判定</strong>: 为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>空间分配担保</strong>: 在发生Minor GC之前,虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间,如果这个条件成立,那么Major GC 可用确保是安全的。如果不成立,虚拟机则会查看HandlePromotionFailure设置值是否允许担保失败,如果允许,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,则进行一次Minor GC ,尽管这次Minor GC室友风险的;如果小于,或者HandlePromotionFailure不允许冒险,那这时就会改为进行一次Full FC</li></ul><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5 引用"></a>5 引用</h2><ul><li>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。为此，在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。</li><li><strong>强引用</strong>: 指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类引用。 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><strong>软引用</strong>: 用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong>: 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li><li><strong>虚引用</strong>: 虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li></ul><h2 id="6-回收方法区"><a href="#6-回收方法区" class="headerlink" title="6 回收方法区"></a>6 回收方法区</h2><ul><li>方法区(永久代)的垃圾回收集主要回收两部分:<strong>废弃常量</strong>和<strong>无用的类(对类型的卸载)</strong></li><li>回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：<blockquote><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；<br>加载该类的ClassLoader已经被回收；<br>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></blockquote></li><li>虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟机类加载机制</title>
      <link href="/2018/05/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/05/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>在了解类加载机制前先看下java程序执行流程<br><img src="/img/jvm/jvm003.jpg" alt="java程序执行流程"><h2 id="1-类加载的过程"><a href="#1-类加载的过程" class="headerlink" title="1. 类加载的过程"></a>1. 类加载的过程</h2></li><li>类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）<br><img src="/img/jvm/jvm004.jpg" alt="类生命周期"></li><li>加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段不一定：它在某些情况下可以初始化阶段之后在开始，这是为了支持Java语言的运行时绑定（也称为动态绑定）。</li><li>加载、验证、准备、解析、初始化这五个步骤组成了一个完整的类加载过程。使用没什么好说的，卸载属于GC的工作</li></ul><h3 id="1-加载-Loading"><a href="#1-加载-Loading" class="headerlink" title="1. 加载(Loading)"></a>1. 加载(Loading)</h3><ul><li><strong>what loading do</strong> <blockquote><ol><li>获取.class文件的二进制流(可以从jar,era,war,applet,jsp获取或者运行时计算生产(动态代理技术))</li><li>将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中</li><li>在内存中生成一个代表这个.class文件的java.lang.Class对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的</li></ol></blockquote></li><li>加载阶段与链接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的,加载阶段尚未完成,连接阶段可能已经开始,但这些夹在加载阶段之中进行的动作仍然属于连接阶段的内容,这两个阶段的开始时间仍然保持这固定的先后顺序</li></ul><h3 id="2-验证-Verification"><a href="#2-验证-Verification" class="headerlink" title="2. 验证(Verification)"></a>2. 验证(Verification)</h3><ul><li><strong>what verification do</strong><blockquote><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol></blockquote></li><li>这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li>Java语言本身是相对安全的语言（相对C/C++来说），但是前面说过，.class文件未必要从Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生.class文件。在字节码语言层面上，Java代码至少从语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</li></ul><h3 id="3-准备-Preparation"><a href="#3-准备-Preparation" class="headerlink" title="3. 准备(Preparation)"></a>3. 准备(Preparation)</h3><ul><li><strong>what preparation do</strong><blockquote><p>为类变量分配内存并设置其初始值</p></blockquote></li><li>这时候进行内存分配的仅仅是类变量（被static修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中</li><li>static变量赋值为0,正常赋值在初始化阶段才进行,final static常量正常赋予用户指定的值<h3 id="4-解析-Resoluting"><a href="#4-解析-Resoluting" class="headerlink" title="4. 解析(Resoluting)"></a>4. 解析(Resoluting)</h3></li><li><strong>what resolution do</strong><blockquote><p>将常量池内的符号引用替换为直接引用</p></blockquote></li><li><strong>符号引用</strong><blockquote><p>符号引用是以一组符号来描述所引用的目标,符号引用可以是任何形式的字面量,只要使用时能无歧义的定位到目标(类、变量、、方法)即可.符号引用与虚拟机实现的内存布局无关,引用的目标并不一定已经加载到内存中.各种虚拟机实现的内存布局可以各不相同,但他们能接受的符号引用必须都是一致的,因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中</p></blockquote></li><li><strong>直接引用</strong><blockquote><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在在内存中了。</p></blockquote><h3 id="5-初始化-Initiallization"><a href="#5-初始化-Initiallization" class="headerlink" title="5. 初始化(Initiallization)"></a>5. 初始化(Initiallization)</h3></li><li><strong>what initiallization do</strong><blockquote><ol><li>给static变量赋予用户指定的值</li><li>执行静态代码块</li><li>若该类具有超类，则对其进行初始化</li></ol></blockquote></li></ul><h4 id="5-1-lt-clinit"><a href="#5-1-lt-clinit" class="headerlink" title="5.1 &lt;clinit>()"></a>5.1 &lt;clinit>()</h4><ul><li><p>&lt;clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并而成,编译器收集的顺序是由语句在源文件中出现的顺序决定的,静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoader &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        i = 0;//给变量赋值可以正常通过</span><br><span class="line">        System.out.println(i);//这句话编译器提示&quot;Illegal forward reference&quot;(非法向前引用)</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&lt;clinit>()方法与类的构造函数不同,它不需要显式的调用父类构造器,虚拟机会保证在子类的&lt;clinit>()方法执行之前父类的&lt;clinit>()方法已经执行完毕.因此在虚拟机中第一个被执行的&lt;clinit>()方法的类肯定是java.lang.Object.由于父类的&lt;clinit>()方法先执行,也就意味着父类定义的静态语句块要优先于子类的变量赋值操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Parent &#123;</span><br><span class="line">    public static int a = 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        a = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Child extends Parent&#123;</span><br><span class="line">    public  static  int b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassLoader &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(Child.b);//result is 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&lt;clinit>()方法对类或接口来说不是必需的,如果一个类中没有静态语句块也没有对类变量的赋值操作,那么编译器可以不为这个类生成&lt;clinit>()方法</p></li><li>虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的&lt;clinit>()方法，其他线程都要阻塞等待，直至活动线程执行&lt;clinit>()方法完毕。因此如果在一个类的&lt;clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行&lt;clinit>()方法的那条线程退出&lt;clinit>()方法后，其他线程不会再次进入&lt;clinit>()方法了，因为同一个类加载器下，一个类只会初始化一次。</li></ul><h4 id="5-2-when-do-initiallization"><a href="#5-2-when-do-initiallization" class="headerlink" title="5.2 when do initiallization"></a>5.2 when do initiallization</h4><ul><li>Java虚拟机规范严格规定了有且只有5种场景必须立即对类进行初始化(而加载,验证,准备,解析自然也要在此之前开始)，这5种场景也称为对一个类进行主动引用<blockquote><ol><li>使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰的静态字段除外）、调用一个类的静态方法的时候</li><li>使用java.lang.reflect包中的方法对类进行反射调用的时候</li><li>初始化一个类，发现其父类还没有初始化过的时候,则需要先触发父类的初始化</li><li>虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类</li><li>看不懂不写了打字很累</li></ol></blockquote></li><li>对于这5种会触发类进行初始化的场景,虚拟机在规范中使用了一个很强烈的限定语:有且只有.除此之外,所有引用类的方式都不会触发类的初始化，称为被动引用，接下来看下被动引用的几个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.子类引用父类静态字段，不会导致子类初始化。至于子类是否被加载、验证了，前者可以通过”-XX:+TraceClassLoading”来查看</span><br><span class="line"></span><br><span class="line">public class SuperClass</span><br><span class="line">&#123;</span><br><span class="line">    public static int value = 123;</span><br><span class="line">     </span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestMain</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为:</span><br><span class="line">SuperClass init</span><br><span class="line">123</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2.通过数组定义引用类，不会触发此类的初始化</span><br><span class="line">public class SuperClass</span><br><span class="line">&#123;</span><br><span class="line">    public static int value = 123;</span><br><span class="line">     </span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestMain</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SuperClass[] scs = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为:(没结果哦)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">3、引用静态常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类</span><br><span class="line">public class ConstClass</span><br><span class="line">&#123;</span><br><span class="line">    public static final String HELLOWORLD =  &quot;Hello World&quot;;</span><br><span class="line">     </span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;ConstCLass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestMain</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为:</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="2-类加载器-ClassLoader"><a href="#2-类加载器-ClassLoader" class="headerlink" title="2. 类加载器(ClassLoader)"></a>2. 类加载器(ClassLoader)</h2><h3 id="2-1-类加载器划分"><a href="#2-1-类加载器划分" class="headerlink" title="2.1 类加载器划分"></a>2.1 类加载器划分</h3><ul><li><strong>启动类加载器(Bootstrap ClassLoader)</strong><blockquote><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 &lt;JAVA_HOME&gt;/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</p></blockquote></li><li><strong>扩展类加载器(Extension ClassLoader)</strong><blockquote><p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载&lt;JAVA_HOME&gt;/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p></blockquote></li><li><strong>应用程序加载类/系统加载类(Application/System ClassLoader)</strong><blockquote><p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。 </p></blockquote><h3 id="2-2-双亲委派模型"><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h3><img src="/img/jvm/jvm005.png" alt="双亲委派模型"></li><li>双亲委派模式(Parents Delegation Model)要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码</li><li>双亲委派模式是在Java 1.2后引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型,而是Java设计者推荐给开发者的一种类加载器的实现方式。</li><li>其工作原理的是:如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//双亲委派模型的实现源码</span><br><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)  </span><br><span class="line">throws ClassNotFoundException  </span><br><span class="line">&#123;  </span><br><span class="line">    //首先， 检查请求的类是否已经被加载过了  </span><br><span class="line">    Class c=findLoadedClass(name);  </span><br><span class="line">    if( c== null )&#123;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            if( parent != null )&#123;  </span><br><span class="line">                c = parent.loadClass(name,false);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                c = findBootstrapClassOrNull(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">        //如果父类加载器抛出ClassNotFoundException  </span><br><span class="line">        //说明父类加载器无法完成加载请求  </span><br><span class="line">        &#125;  </span><br><span class="line">        if( c == null ) &#123;  </span><br><span class="line">            //在父类加载器无法加载的时候  </span><br><span class="line">            //再调用本身的findClass方法来进行类加载  </span><br><span class="line">            c = findClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    if(resolve)&#123;  </span><br><span class="line">        resolveClass(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-类加载器工作原理"><a href="#2-3-类加载器工作原理" class="headerlink" title="2.3 类加载器工作原理"></a>2.3 类加载器工作原理</h3><p>类加载器的工作原理基于三个机制：委托、可见性和单一性。</p><ul><li>委托机制(与双亲委派模型工作原理一样)</li><li>可行性机制<blockquote><p>子类加载器可以看到父类加载器加载的类，而反之则不行</p></blockquote></li><li>单一性机制<blockquote><p>父加载器加载过的类不能被子加载器加载第二次</p></blockquote></li></ul><h3 id="2-4-如何显示的加载类"><a href="#2-4-如何显示的加载类" class="headerlink" title="2.4  如何显示的加载类"></a>2.4  如何显示的加载类</h3><ul><li>Java提供了显式加载类的API：Class.forName(classname)和Class.forName(classname, initialized, classloader)，你可以指定类加载器的名称以及要加载的类的名称。类的加载是通过调用java.lang.ClassLoader的loadClass()方法，而loadClass()方法则调用了findClass()方法来定位相应类的字节码。</li><li>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象</li><li>所谓class文件的显示加载与隐式加载的方式是指JVM加载class文件到内存的方式，显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。而隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java内存区域</title>
      <link href="/2018/05/23/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2018/05/23/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><p><img src="/img/jvm/jvm001.png" alt="运行时数据区"></p><h2 id="1-线程独占区"><a href="#1-线程独占区" class="headerlink" title="1. 线程独占区"></a>1. 线程独占区</h2><h3 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h3><ul><li>程序计数器是一块较小的内存空间,它可以看做是当前线程所执行的字节码的行号指示器</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>由于JVM的多线程是通过并发来实现的,在任何一个确定的时刻,一个处理器都只会执行一条线程中的指令,故其是线程私有的内存</li><li>如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（undefined）。此内存区域是唯一一个在虚拟机规范中不会出现OutofMemoryError的区域<h3 id="1-2-Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#1-2-Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="1.2 Java虚拟机栈(Java Virtual Machine Stacks)"></a>1.2 Java虚拟机栈(Java Virtual Machine Stacks)</h3></li><li>存储内容: 基础数据类型的对象和自定义对象的引用</li><li>Java虚拟机栈也是线程私有的，它的生命周期与线程相同,这块内存区域就是我们常说的”栈</li><li>虚拟机描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</li><li>局部变量表存放了编译期可知的各种基本类型（boolean,byte,char,short,int,float,long,double）、对象引用和returnAddress(指向了一条字节码指令的地址)类型。</li><li>栈分为三个部分:  基本类型变量区、执行环境上下文、操作指令区<h3 id="1-3-本地方法栈-Native-Method-Stack"><a href="#1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="1.3 本地方法栈(Native Method Stack)"></a>1.3 本地方法栈(Native Method Stack)</h3></li><li>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机执行java方法，也就是字节码服务，而本地方法栈则为虚拟机使用的Native方法服务。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把虚拟机栈和本地方法栈合二为一<h2 id="2-线程共享区"><a href="#2-线程共享区" class="headerlink" title="2. 线程共享区"></a>2. 线程共享区</h2><h3 id="2-1-Java堆-Java-Heap"><a href="#2-1-Java堆-Java-Heap" class="headerlink" title="2.1 Java堆(Java Heap)"></a>2.1 Java堆(Java Heap)</h3></li><li>存储内容:存储的全部是对象,每个对象都包含一个与之对应的class的信息(目的是得到操作指令)</li><li>从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以还可以细分为：新生代（Young Generation）、老年代（Old Generation）。对于新生代又分为：Eden空间，From Survivor空间，ToSurvivor空间</li><li>从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）<h3 id="2-2-方法区-Method-Area"><a href="#2-2-方法区-Method-Area" class="headerlink" title="2.2 方法区(Method Area)"></a>2.2 方法区(Method Area)</h3></li><li>存储内容: 所有的class(字节码文件)和static变量,方法区中包含的都是在整个程序中永远唯一的元素</li><li><p>对于JVM的方法区，可能听得最多的是另外一个说法——永久代（Permanent Generation），呼应堆的新生代和老年代。方法区和堆的划分是JVM规范的定义，而不同虚拟机有不同实现，对于Hotspot虚拟机来说，将方法区纳入GC管理范围，这样就不必单独管理方法区的内存，所以就有了”永久代“这么一说，但使用永久代来实现方法区现在看来并不是很好，因为这样更容易遇到内存溢出的问题，（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如64为系统中的4GB，就不会有问题），而且有极少数方法（例如String.intern()）会因为这个原因导致不同虚拟机下有不同的表现。因此，现在对于HotSpot虚拟机，已经改为采用Native Memory来实现方法区规划了，而且在JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。<br><strong>举例</strong><br>现设置JVM参数为”-XX:MaxPermSize=20M”（方法区最大内存为20M）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际上对于以上代码，在JDK6、JDK7、JDK8运行结果均不一样。原因就在于字符串常量池在JDK6的时候还是存放在方法区（永久代）所以它会抛出OutOfMemoryError:Permanent Space；而JDK7后则将字符串常量池移到了Java堆中，上面的代码不会抛出OOM，若将堆内存改为20M则会抛出OutOfMemoryError:Java heap space；至于JDK8则是纯粹取消了方法区这个概念，取而代之的是”元空间（Metaspace）“，所以在JDK8中虚拟机参数”-XX:MaxPermSize”也就没有了任何意义，取代它的是”-XX:MetaspaceSize“和”-XX:MaxMetaspaceSize”等。</p><h4 id="2-2-1-运行时常量池-Runtime-Constant-Pool"><a href="#2-2-1-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="2.2.1 运行时常量池(Runtime Constant Pool)"></a>2.2.1 运行时常量池(Runtime Constant Pool)</h4></li><li>运行时常量池是方法区的一部分,Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放</li><li>Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是String类的intern()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       String s1 = &quot;abc&quot;;</span><br><span class="line">       String s2 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">       String s3= new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(s1 == s2);　//true</span><br><span class="line">       System.out.println(s2 == s3);  //false</span><br><span class="line">       System.out.println(s2 == s3.intern());  //true </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-直接内存"><a href="#3-直接内存" class="headerlink" title="3. 直接内存"></a>3. 直接内存</h2><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现</li><li>在ＪＤＫ1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆中来回复制数据。<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><img src="/img/jvm/jvm002.png" alt="总结"></li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a>  </p><h2 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h2><h4 id="①-懒汉式-线程不安全"><a href="#①-懒汉式-线程不安全" class="headerlink" title="①.懒汉式-线程不安全"></a>①.懒汉式-线程不安全</h4><ul><li>线程不安全,Lazy加载</li><li>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程</li><li>因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SlackerThreadNoSafe &#123;</span><br><span class="line">    private static SlackerThreadNoSafe slackerThreadNoSafe;</span><br><span class="line"></span><br><span class="line">    private SlackerThreadNoSafe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SlackerThreadNoSafe getInstance() &#123;</span><br><span class="line">        if (slackerThreadNoSafe == null) &#123;</span><br><span class="line">            slackerThreadNoSafe = new SlackerThreadNoSafe();</span><br><span class="line">        &#125;</span><br><span class="line">        return slackerThreadNoSafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="②-懒汉式-线程安全"><a href="#②-懒汉式-线程安全" class="headerlink" title="②.懒汉式-线程安全"></a>②.懒汉式-线程安全</h4><ul><li>线程安全,Lazy加载</li><li>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是效率很低.  </li><li>优点：第一次调用才初始化，避免内存浪费。  </li><li>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SlackerThreadSafe &#123;</span><br><span class="line">    private static SlackerThreadSafe slackerThreadSafe;</span><br><span class="line"></span><br><span class="line">    private SlackerThreadSafe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SlackerThreadSafe getInstance() &#123;</span><br><span class="line">        if (slackerThreadSafe == null) &#123;</span><br><span class="line">            slackerThreadSafe = new SlackerThreadSafe();</span><br><span class="line">        &#125;</span><br><span class="line">        return slackerThreadSafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、饿汉式"><a href="#2、饿汉式" class="headerlink" title="2、饿汉式"></a>2、饿汉式</h2><ul><li>线程安全,非Lazy加载</li><li>优点：没有加锁，执行效率会提高。</li><li>缺点：类加载时就初始化，浪费内存。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class StarvingModel &#123;</span><br><span class="line">    private static StarvingModel starvingModel = new StarvingModel();</span><br><span class="line"></span><br><span class="line">    private StarvingModel() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StarvingModel getInstance() &#123;</span><br><span class="line">        return starvingModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3、双检锁-双重校验锁"><a href="#3、双检锁-双重校验锁" class="headerlink" title="3、双检锁/双重校验锁"></a>3、双检锁/双重校验锁</h2><ul><li>线程安全, Lazy加载</li><li>这种方式采用双锁机制，安全且在多线程情况下能保持高性能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123;</span><br><span class="line">    private static DoubleCheckedLocking doubleCheckedLocking;</span><br><span class="line">    private DoubleCheckedLocking()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static DoubleCheckedLocking getInstance()&#123;</span><br><span class="line">        if (doubleCheckedLocking == null)&#123;</span><br><span class="line">            synchronized (DoubleCheckedLocking.class)&#123;</span><br><span class="line">                if (doubleCheckedLocking == null)&#123;</span><br><span class="line">                    doubleCheckedLocking = new DoubleCheckedLocking();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleCheckedLocking;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4、登记式-静态内部类"><a href="#4、登记式-静态内部类" class="headerlink" title="4、登记式/静态内部类"></a>4、登记式/静态内部类</h2><ul><li>线程安全  Lazy加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClassModel &#123;</span><br><span class="line">    private static class Single&#123;</span><br><span class="line">        private static final InnerClassModel INNER_CLASS_MODEL = new InnerClassModel();</span><br><span class="line">    &#125;</span><br><span class="line">    private InnerClassModel()&#123;&#125;</span><br><span class="line">    public static final InnerClassModel getInstance()&#123;</span><br><span class="line">        return Single.INNER_CLASS_MODEL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h2><ul><li>线程安全.非Lazy加载</li><li>自动支持序列化机制，防止反序列化重新创建新的对象</li><li>绝对防止多次实例化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumModel &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // you can use EnumModel.INSTANCE.doSomeThing();</span><br><span class="line">    // you can only be a single case.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><ul><li>菜鸟说: 一般情况下，不建议使用懒汉式，建议使用饿汉式。只有在要明确实现 lazy loading 效果时，才会使用登记式。如果涉及到反序列化创建对象时，可以尝试使用枚举式。如果有其他特殊的需求，可以考虑使用双检锁式。</li></ul>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>葬花吟</title>
      <link href="/2018/05/16/%E8%91%AC%E8%8A%B1%E5%90%9F/"/>
      <url>/2018/05/16/%E8%91%AC%E8%8A%B1%E5%90%9F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a><br>花谢花飞花满天，红消香断有谁怜？<br>游丝软系飘春榭，落絮轻沾扑绣帘。<br>闺中女儿惜春暮，愁绪满怀无释处。<br>手把花锄出绣帘，忍踏落花来复去。<br>柳丝榆荚自芳菲，不管桃飘与李飞；<br>桃李明年能再发，明年闺中知有谁？<br>三月香巢已垒成，梁间燕子太无情！<br>明年花发虽可啄，却不道人去梁空巢也倾。<br>一年三百六十日，风刀霜剑严相逼；<br>明媚鲜妍能几时，一朝漂泊难寻觅。<br>花开易见落难寻，阶前愁杀葬花人，<br>独倚花锄泪暗洒，洒上空枝见血痕。<br>杜鹃无语正黄昏，荷锄归去掩重门；<br>青灯照壁人初睡，冷雨敲窗被未温。<br>怪奴底事倍伤神？半为怜春半恼春。<br>怜春忽至恼忽去，至又无言去未闻。<br>昨宵庭外悲歌发，知是花魂与鸟魂？<br>花魂鸟魂总难留，鸟自无言花自羞；<br>愿侬此日生双翼，随花飞到天尽头。<br>天尽头，何处有香丘？<br>未若锦囊收艳骨，一抔净土掩风流。<br>质本洁来还洁去，强于污淖陷渠沟。<br>尔今死去侬收葬，未卜侬身何日丧？<br>侬今葬花人笑痴，他年葬侬知是谁？<br>试看春残花渐落，便是红颜老死时；<br>一朝春尽红颜老，花落人亡两不知！ </p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>md语法格式</title>
      <link href="/2018/05/16/md%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"/>
      <url>/2018/05/16/md%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><em>Add this line to Using the more label,but it’s too short to look bad,addition point length</em><br><a id="more"></a></p><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>列表1</li><li>列表2</li><li>列表3 <h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3></li></ul><ol><li>列表1</li><li>列表1</li><li>列表1</li></ol><h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3. 区块引用"></a>3. 区块引用</h2><ol><li>毛主席曾经说过<blockquote><p>不以结婚为目的的谈恋爱都叫耍流氓</p></blockquote></li><li>听说你缺个对象<blockquote><p>Object object = new Object();</p></blockquote></li><li><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p><blockquote><p>五级引用</p><blockquote><p>六级引用</p><blockquote><p>七级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></li></ol><h2 id="4-华丽的分割线"><a href="#4-华丽的分割线" class="headerlink" title="4.华丽的分割线"></a>4.华丽的分割线</h2><h6 id="（这就华丽了吗．．）"><a href="#（这就华丽了吗．．）" class="headerlink" title="（这就华丽了吗．．）"></a>（这就华丽了吗．．）</h6><hr><hr><hr><hr><h2 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>   <a href="http://baike.baidu.com/item/md/2258949?fr=aladdin" target="_blank" rel="noopener">md</a>是什么意思?</p><h3 id="参数式"><a href="#参数式" class="headerlink" title="参数式"></a>参数式</h3><p>点击<a href="http://www.baidu.com" target="_blank" rel="noopener">这里搜索</a>,点击<a href="http://www.baidu.com" target="_blank" rel="noopener">这里也可以搜索</a></p><h2 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h2><h5 id="用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的"><a href="#用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的" class="headerlink" title="用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的"></a>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</h5><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p>怎么图片<img src="https://www.baidu.com/img/bd_logo1.png" alt="好像不需要写东西">的行内式是好的</p><h3 id="参数式-1"><a href="#参数式-1" class="headerlink" title="参数式"></a>参数式</h3><p><img src="https://www.baidu.com/img/bd_logo1.png" alt="好像可以随便写东西">大小难道又用ps调?</p><h2 id="7-代码框"><a href="#7-代码框" class="headerlink" title="7.代码框"></a>7.代码框</h2><h3 id="单行代码用"><a href="#单行代码用" class="headerlink" title="单行代码用"></a>单行代码用<code></code></h3><p><code>Object object = new Object()</code></p><h3 id="段落文本代码块"><a href="#段落文本代码块" class="headerlink" title="段落文本代码块"></a>段落文本代码块</h3><pre><code>这是一个代码块，此行左侧有四个不可见的空格这是代码块，会自动添加行号，注意要与前面文字空行，</code></pre><h2 id="8-强行换行"><a href="#8-强行换行" class="headerlink" title="8.强行换行"></a>8.强行换行</h2><p>就在需要换行的地方<br>加两个空格就Ok了<br>就<br>比<br>如<br>这<br>样  </p><h2 id="9-强调"><a href="#9-强调" class="headerlink" title="9.强调"></a>9.强调</h2><p><em>字体倾斜</em><br><strong>字体加粗</strong></p><h2 id="10-删除线"><a href="#10-删除线" class="headerlink" title="10.删除线"></a>10.删除线</h2><p><del>今晚不做一百个俯卧撑不睡觉</del><br>算了当我没说,再吃个鸡腿就睡觉</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
